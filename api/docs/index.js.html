<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>let _ = require("./_");
let EventEmitter = require('eventemitter3');
// let { performance } = require("perf_hooks");

Math.cantor = function(a, b) {
  a = parseInt(a); b = parseInt(b); // cast to integer
  return ((a + b) * (a + b + 1)) / 2 + b;
}

function Connection(options={}) {};
function Node(options={}) {};
function Network(options={}) {};

Connection = _.extend(Connection, EventEmitter);
Connection = _.extend(Connection, function(options={}) {
  this.id = options.id || Math.cantor(options.from, options.to);
});
Node = _.extend(Node, EventEmitter);
Node = _.extend(Node, function(options={}) {
  this.id = options.id;
});
Network = _.extend(Network, EventEmitter);
Network = _.extend(Network, function(options={}) {
  // constructor defaults
  options.inputs = options.inputs || 1;
  options.outputs = options.outputs || 1;

  // genome
  this.inputs = {};
  this.outputs = {};
  this.nodes = {};
  this.connections = {};
  this.NODES = 0;

  // new Network({ inputs, outputs })
  // create input nodes
  for (let i = 0; i &lt; options.inputs; i++) {
    this.inputs[this.NODES] = this.nodes[this.NODES] = new Node({ id: this.NODES });
    ++this.NODES;
  }
  // create output nodes
  for (let o = 0; o &lt; options.outputs; o++) {
    this.outputs[this.NODES] = this.nodes[this.NODES] = new Node({ id: this.NODES });
    ++this.NODES;
  }
  // connect input nodes to output nodes
  for (input in this.inputs) {
    for (output in this.outputs) {
      // connect input node to output node
      let connection = new Connection({ from: input, to: output });
      this.connections[connection.id] = connection;
    }
  }
});

// Node JSON Export
_.mixin(Node, {
  toJSON: function(options={}) {
    return { id: this.id }
  }
}, { prototype: true });

// Network Visualization Vis.js
_.mixin(Network, {
  /**
  * Returns a JSON representation of the network
  *
  * @returns {Object}
  */
  toJSON: function toJSON() {
    const neurons = Object.values(this.nodes).flat(Infinity).map(function(neuron) {
      return neuron.toJSON();
    });
    const connections = Object.values(this.connections).flat(Infinity).map(function(connection) {
      return connection.toJSON();
    });
    return { neurons, connections }
  },

  /**
  * **BROWSER ONLY**
  *
  * Creates a graph of the network using [`vis-network`](https://www.npmjs.com/package/vis-network) on the given DOMElement
  * or DOMElement ID.
  *
  * @param {string|DOMElement} element - DOMElement, or ID, where graph will ported into
  * @param {Object} [options] - `vis-network` options - [learn more](https://visjs.github.io/vis-network/docs/network/#options)
  */
  toGraph: function toGraph(element, options) {
    const { neurons, connections } = this.toJSON();

    // Flattens neuron layers from `Network.toJSON` and converts it to `vie-network`
    // nodes
    const nodes = new vis.DataSet(neurons.map(function(neuron) {
      neuron.label = `${neuron.id}`;
      neuron.color = neuron.type === "input" ? "gray" : neuron.type === "output" ? "lime" : "orange"; // "input" || "output" || "hidden"
      return neuron;
    }));
    // Flattens connections from `Network.toJSON` and converts it into `vis-network`
    // edges
    const edges = new vis.DataSet(connections.map(function(connection) {
      connection.arrows = "to";
      return connection;
    }));

    // DOM id
    if(typeof element === "string") element = document.getElementById(element);

    // Vis.js Network Options
    // Will have a "left-to-right" graph with "smooth" lines representing
    // connections by default
    options = options || {
      edges: {
        smooth: {
          type: "cubicBezier",
          forceDirection: "horizontal"
        }
      },
      layout: {
        hierarchical: {
          direction: "LR",
          sortMethod: "directed"
        }
      },
      physics: false
    }

    return new vis.Network(element, { nodes, edges }, options);
  }
}, { prototype: true })

// Possible "network-scope" mutations
_.mixin(Network, {
  mutations: {
    "ADD_NODE": function(network, options={}) {},
    "REMOVE_NODE": function(network, options={}) {},
    "ADD_CONNECTION": function(network, options={}) {},
    "REMOVE_CONNECTION": function(network, options={}) {}
  }
});

// NEAT Mutation Helpers
_.mixin(Network, {
  additions: {}, // tracks `Node` additions to the network - creating a key-value pair of the bisected connection's Cantor Pair ID and the bisecting Node's ID, respectively; NOTE: this is useful to ensure that IDs are structurally unique across networks training in a population or acrosss time; if a new node bisects a connection, is removed, and later added again - it should not be address as a new node, but rather as an existing node being "turned on" again.
  removals: {}, // tracks `Node` removals to the network - creating a key-value pair of the emerging connection's Cantor Pair ID and the IDs of the removed connections; NOTE: when a `node` is removed from the network, at least one pair of connections are also removed from the network
  mutate: function(options={}) {
    let mutations = Object.keys(Network.mutations);
    options.mutation = options.mutation || Network.mutations[mutations[Math.floor(Math.random() * mutations.length)]]; // use the given mutation or a random one
  }
}, { prototype: true });

// No Endpoints - Synaptic Weight - No Delay - No ID
if (false) {
  Connection = _.extend(Connection, function(options={}) {
    this.weight = options.weight || Math.random() * 2 - 1;
  });

  let noweight = new Connection();
  let weighted = new Connection({
    weight: 0.3
  });

  console.log(noweight);
  console.log(weighted);
}

// ID Endpoints - Synaptic Weight - No Delay - No ID
if (false) {
  Connection = _.extend(Connection, function(options={}) {
    this.from = options.from; // @prop {string|number} from
    this.to = options.to; // @prop {string|number} to
  });

  let connected = new Connection({
    from: 0,
    to: 1
  });

  console.log(connected);
}

// ID Endpoints - Synaptic Weight - No Delay - Network Context Sequantially Based IDs
if (false) {
  _.mixin(Network, { CONNECTIONS: 0 }, { prototype: true });
  _.mixin(Network, {
    connection: function() {
      return ++this.CONNECTIONS;
    }
  }, { prototype: true });

  // Connection = _.extend(Connection, function(options={}) {
  //   this.from = options.from; // @prop {string|number} from
  //   this.to = options.to; // @prop {string|number} to
  // });

  Connection = _.extend(Connection, function(options={}) {
    this.context = options.context;
    this.id = this.context.connection();
  });

  let network = new Network();

  console.log(network);
  console.log(network.CONNECTIONS);

  let connection = new Connection({
    context: network,
    from: 0,
    to: 1
  });

  console.log(connection);

  let otherConnection = new Connection({
    context: network,
    from: 1,
    to: 2
  });

  console.log(otherConnection);
}

if (false) {
  function something(options={}) {
    this.meta = {};

    // track `stream`
    this.meta.prestream = function() {};
    this.meta.stream = function() {};
    this.meta.poststream = function() {};

    // create `meta` &amp; `state`
    this.meta.precreate = function() {};
    this.meta.created = function() {};
    this.meta.postcreate = function() {};

    // update `state`
    this.meta.preupdate = function() {};
    this.meta.update = function() {};
    this.meta.postupdate = function() {};

    this.state = {};

    this.stream.forward = [];
    this.stream.backward = [];

    this.push = function() {};
    this.pull = function() {};
  }
}

if (false) {
  function Class(options={}) {
    this.data = {};
    this.computed = {};
    this.methods = {};
    this.streams = {};
  }

  Connection = _.extend(Connection, Class);
  Network = _.extend(Network, Class);

  Connection = _.extend(Connection, function(options={}) {
    this.data = Object.assign(this.data, options.data);
  });

  let network = new Network();
  let connection = new Connection({
    data: {
      context: network
    },
  });

  console.log(connection);
}

{
  let connection = new Connection();


  // let start = performance.now();
  let start = Date.now();

  let network = new Network({
    inputs: 5,
    outputs: 4
  });

  // let end  = performance.now();
  let end  = Date.now();

  console.log(end - start);

  // console.log(Connection);
  // console.log(Network);

  // console.log(connection);
  // console.log(connection);
  // console.log(network);
}

module.exports._ = _;
module.exports.Connection = Connection;
module.exports.Node = Node;
module.exports.Network = Network;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#toGraph">toGraph</a></li><li><a href="global.html#toJSON">toJSON</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Sat Nov 16 2019 16:52:16 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
