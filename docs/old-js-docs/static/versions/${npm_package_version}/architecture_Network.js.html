<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Liquid Carrot - architecture/Network.js - Documentation</title>
    <link rel="shortcut icon" href="/liquid-carrot-favicon.png" />
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="styles/bulma.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/ionicons/2.0.1/css/ionicons.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger">
  <div class="fixed-action-btn">
    <div class="button-floating">
      <!--
      <label for="nav-trigger" class="navicon-button x">
        <div class="navicon"></div>
      </label>
      -->
        <i class="ion-ios-book" aria-hidden="true"></i>
    </div>
  </div>
</label>
<label for="nav-trigger" class="overlay"></label>

<div class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="#" style="padding:0">
      <img src="img/carrot-logo.png" height="28">
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      <a class="navbar-item" href="/">Home</a>
      <a class="navbar-item" href="/carrot">Docs</a>
      <a class="navbar-item" href="https://github.com/liquidcarrot/carrot" target="_blank"><i class="ion-social-github" aria-hidden="true"></i></a>
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">
          Versions
        </a>
        
        <div class="navbar-dropdown">
          <a href='https://liquidcarrot.io/carrot/versions/0.2.27/' class="navbar-item">v0.2.27</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.2.28/' class="navbar-item">v0.2.28</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.0/' class="navbar-item">v0.3.0</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.1/' class="navbar-item">v0.3.1</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.10/' class="navbar-item">v0.3.10</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.11/' class="navbar-item">v0.3.11</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.12/' class="navbar-item">v0.3.12</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.16/' class="navbar-item">v0.3.16</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.18/' class="navbar-item">v0.3.18</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.3/' class="navbar-item">v0.3.3</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.4/' class="navbar-item">v0.3.4</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.7/' class="navbar-item">v0.3.7</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.8/' class="navbar-item">v0.3.8</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.9/' class="navbar-item">v0.3.9</a>
      <a href='https://liquidcarrot.io/carrot/' class="navbar-item">latest</a>
        </div>
      </div>
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">
          More
        </a>

        <div class="navbar-dropdown">
          <a class="navbar-item" href="mailto:people@liquidcarrot.io?subject=Contact%20From%20Docs">
            Contact
          </a>
          <hr class="navbar-divider">
          <a class="navbar-item" href="https://github.com/liquidcarrot/carrot/issues/new">
            Report an issue
          </a>
        </div>
      </div>
    </div>

    <div class="navbar-end">
      <div class="navbar-item">
        <input type="text" id="nav-search" placeholder="Search" autofocus>
      </div>
    </div>
  </div>
</div>

<nav >
    <h3>Classes</h3><ul><li><a href="Neat.html">Neat</a><ul class='methods'><li data-type='method'><a href="Neat.html#evaluate">evaluate</a></li><li data-type='method'><a href="Neat.html#evolve">evolve</a></li><li data-type='method'><a href="Neat.html#filterGenome">filterGenome</a></li><li data-type='method'><a href="Neat.html#getAverage">getAverage</a></li><li data-type='method'><a href="Neat.html#getFittest">getFittest</a></li><li data-type='method'><a href="Neat.html#getOffspring">getOffspring</a></li><li data-type='method'><a href="Neat.html#mutate">mutate</a></li><li data-type='method'><a href="Neat.html#mutateRandom">mutateRandom</a></li><li data-type='method'><a href="Neat.html#sort">sort</a></li></ul></li><li><a href="Network.html">Network</a><ul class='methods'><li data-type='method'><a href="Network.html#.crossOver">crossOver</a></li><li data-type='method'><a href="Network.html#.fromJSON">fromJSON</a></li><li data-type='method'><a href="Network.html#activate">activate</a></li><li data-type='method'><a href="Network.html#addGate">addGate</a></li><li data-type='method'><a href="Network.html#clear">clear</a></li><li data-type='method'><a href="Network.html#connect">connect</a></li><li data-type='method'><a href="Network.html#copy">copy</a></li><li data-type='method'><a href="Network.html#disconnect">disconnect</a></li><li data-type='method'><a href="Network.html#evolve">evolve</a></li><li data-type='method'><a href="Network.html#mutate">mutate</a></li><li data-type='method'><a href="Network.html#mutateRandom">mutateRandom</a></li><li data-type='method'><a href="Network.html#propagate">propagate</a></li><li data-type='method'><a href="Network.html#removeGate">removeGate</a></li><li data-type='method'><a href="Network.html#removeNode">removeNode</a></li><li data-type='method'><a href="Network.html#test">test</a></li><li data-type='method'><a href="Network.html#toJSON">toJSON</a></li><li data-type='method'><a href="Network.html#train">train</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#AbsoluteActivation">AbsoluteActivation</a></li><li><a href="global.html#Activation">Activation</a></li><li><a href="global.html#ActivationType">ActivationType</a></li><li><a href="global.html#ActivationType%255Bundefined%255D">ActivationType[undefined]</a></li><li><a href="global.html#AddBackConnectionMutation">AddBackConnectionMutation</a></li><li><a href="global.html#AddConnectionMutation">AddConnectionMutation</a></li><li><a href="global.html#AddGateMutation">AddGateMutation</a></li><li><a href="global.html#AddNodeMutation">AddNodeMutation</a></li><li><a href="global.html#AddSelfConnectionMutation">AddSelfConnectionMutation</a></li><li><a href="global.html#ALL_MUTATIONS">ALL_MUTATIONS</a></li><li><a href="global.html#Architect">Architect</a></li><li><a href="global.html#avg">avg</a></li><li><a href="global.html#AvgPooling1DLayer">AvgPooling1DLayer</a></li><li><a href="global.html#BentIdentityActivation">BentIdentityActivation</a></li><li><a href="global.html#BinaryLoss">BinaryLoss</a></li><li><a href="global.html#BipolarActivation">BipolarActivation</a></li><li><a href="global.html#BipolarSigmoidActivation">BipolarSigmoidActivation</a></li><li><a href="global.html#Connection">Connection</a></li><li><a href="global.html#ConnectionType">ConnectionType</a></li><li><a href="global.html#ConnectionType%255Bundefined%255D">ConnectionType[undefined]</a></li><li><a href="global.html#ConstantNode">ConstantNode</a></li><li><a href="global.html#CrossEntropyLoss">CrossEntropyLoss</a></li><li><a href="global.html#DenseLayer">DenseLayer</a></li><li><a href="global.html#DropoutLayer">DropoutLayer</a></li><li><a href="global.html#DropoutNode">DropoutNode</a></li><li><a href="global.html#ExponentialRate">ExponentialRate</a></li><li><a href="global.html#FEEDFORWARD_MUTATIONS">FEEDFORWARD_MUTATIONS</a></li><li><a href="global.html#FitnessProportionateSelection">FitnessProportionateSelection</a></li><li><a href="global.html#FixedRate">FixedRate</a></li><li><a href="global.html#GatingType">GatingType</a></li><li><a href="global.html#GatingType%255Bundefined%255D">GatingType[undefined]</a></li><li><a href="global.html#GaussianActivation">GaussianActivation</a></li><li><a href="global.html#generateGaussian">generateGaussian</a></li><li><a href="global.html#getOrDefault">getOrDefault</a></li><li><a href="global.html#GlobalAvgPooling1DLayer">GlobalAvgPooling1DLayer</a></li><li><a href="global.html#GlobalMaxPooling1DLayer">GlobalMaxPooling1DLayer</a></li><li><a href="global.html#GlobalMinPooling1DLayer">GlobalMinPooling1DLayer</a></li><li><a href="global.html#GRULayer">GRULayer</a></li><li><a href="global.html#HardTanhActivation">HardTanhActivation</a></li><li><a href="global.html#HINGELoss">HINGELoss</a></li><li><a href="global.html#HopfieldLayer">HopfieldLayer</a></li><li><a href="global.html#IdentityActivation">IdentityActivation</a></li><li><a href="global.html#InputLayer">InputLayer</a></li><li><a href="global.html#InverseActivation">InverseActivation</a></li><li><a href="global.html#InverseRate">InverseRate</a></li><li><a href="global.html#Layer">Layer</a></li><li><a href="global.html#LogisticActivation">LogisticActivation</a></li><li><a href="global.html#Loss">Loss</a></li><li><a href="global.html#LSTMLayer">LSTMLayer</a></li><li><a href="global.html#MAELoss">MAELoss</a></li><li><a href="global.html#MAPELoss">MAPELoss</a></li><li><a href="global.html#max">max</a></li><li><a href="global.html#MaxPooling1DLayer">MaxPooling1DLayer</a></li><li><a href="global.html#maxValueIndex">maxValueIndex</a></li><li><a href="global.html#MemoryLayer">MemoryLayer</a></li><li><a href="global.html#min">min</a></li><li><a href="global.html#MinPooling1DLayer">MinPooling1DLayer</a></li><li><a href="global.html#minValueIndex">minValueIndex</a></li><li><a href="global.html#MISHActivation">MISHActivation</a></li><li><a href="global.html#ModActivationMutation">ModActivationMutation</a></li><li><a href="global.html#ModBiasMutation">ModBiasMutation</a></li><li><a href="global.html#ModWeightMutation">ModWeightMutation</a></li><li><a href="global.html#MSELoss">MSELoss</a></li><li><a href="global.html#MSLELoss">MSLELoss</a></li><li><a href="global.html#Mutation">Mutation</a></li><li><a href="global.html#Node">Node</a></li><li><a href="global.html#NodeType">NodeType</a></li><li><a href="global.html#NodeType%255Bundefined%255D">NodeType[undefined]</a></li><li><a href="global.html#NoiseLayer">NoiseLayer</a></li><li><a href="global.html#NoiseNode">NoiseNode</a></li><li><a href="global.html#NoiseNodeType">NoiseNodeType</a></li><li><a href="global.html#NoiseNodeType%255Bundefined%255D">NoiseNodeType[undefined]</a></li><li><a href="global.html#OutputLayer">OutputLayer</a></li><li><a href="global.html#pickRandom">pickRandom</a></li><li><a href="global.html#PoolingLayer">PoolingLayer</a></li><li><a href="global.html#PoolNode">PoolNode</a></li><li><a href="global.html#PoolNodeType">PoolNodeType</a></li><li><a href="global.html#PoolNodeType%255Bundefined%255D">PoolNodeType[undefined]</a></li><li><a href="global.html#PowerSelection">PowerSelection</a></li><li><a href="global.html#randBoolean">randBoolean</a></li><li><a href="global.html#randDouble">randDouble</a></li><li><a href="global.html#randInt">randInt</a></li><li><a href="global.html#Rate">Rate</a></li><li><a href="global.html#RELUActivation">RELUActivation</a></li><li><a href="global.html#removeFromArray">removeFromArray</a></li><li><a href="global.html#RNNLayer">RNNLayer</a></li><li><a href="global.html#Selection">Selection</a></li><li><a href="global.html#SELUActivation">SELUActivation</a></li><li><a href="global.html#shuffle">shuffle</a></li><li><a href="global.html#SinusoidActivation">SinusoidActivation</a></li><li><a href="global.html#SoftSignActivation">SoftSignActivation</a></li><li><a href="global.html#StepActivation">StepActivation</a></li><li><a href="global.html#StepRate">StepRate</a></li><li><a href="global.html#SubBackConnectionMutation">SubBackConnectionMutation</a></li><li><a href="global.html#SubConnectionMutation">SubConnectionMutation</a></li><li><a href="global.html#SubGateMutation">SubGateMutation</a></li><li><a href="global.html#SubNodeMutation">SubNodeMutation</a></li><li><a href="global.html#SubSelfConnectionMutation">SubSelfConnectionMutation</a></li><li><a href="global.html#sum">sum</a></li><li><a href="global.html#SwapNodesMutation">SwapNodesMutation</a></li><li><a href="global.html#TanhActivation">TanhActivation</a></li><li><a href="global.html#TournamentSelection">TournamentSelection</a></li><li><a href="global.html#WAPELoss">WAPELoss</a></li></ul>
</nav>

<div id="main">
    <div class="columns">
        <div class="column is-hidden-touch"></div>
        <div class="column is-11-desktop is-10-widescreen">

            
                <h1 class="page-title">architecture/Network.js</h1>
            

            



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this &amp;&amp; this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] &amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" &amp;&amp; (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y &amp;&amp; (t = op[0] &amp; 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) &amp;&amp; t.call(y), 0) : y.next) &amp;&amp; !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] &amp; 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 &amp;&amp; (!t || (op[1] > t[0] &amp;&amp; op[1] &lt; t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) { _.label = t[1]; t = op; break; }
                    if (t &amp;&amp; _.label &lt; t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] &amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var NodeType_1 = require("../enums/NodeType");
var Loss_1 = require("../methods/Loss");
var Mutation_1 = require("../methods/Mutation");
var Rate_1 = require("../methods/Rate");
var Utils_1 = require("../methods/Utils");
var NEAT_1 = require("../NEAT");
var Connection_1 = require("./Connection");
var Node_1 = require("./Node");
/**
 * Create a neural network
 *
 * Networks are easy to create, all you need to specify is an `input` and an `output` size.
 *
 * @constructs Network
 *
 * @param {number} inputSize Size of input layer AKA neurons in input layer
 * @param {number} outputSize Size of output layer AKA neurons in output layer
 *
 * @prop {number} inputSize Size of input layer AKA neurons in input layer
 * @prop {number} outputSize Size of output layer AKA neurons in output layer
 * @prop {Array&lt;Node>} nodes Nodes currently within the network
 * @prop {Array&lt;Node>} gates Gates within the network
 * @prop {Array&lt;Connection>} connections Connections within the network
 *
 * @example
 * let { Network } = require("@liquid-carrot/carrot");
 *
 * // Network with 2 input neurons and 1 output neuron
 * let myNetwork = new Network(2, 1);
 */
var Network = /** @class */ (function () {
    function Network(inputSize, outputSize) {
        this.inputSize = inputSize;
        this.outputSize = outputSize;
        this.nodes = [];
        this.connections = [];
        this.gates = [];
        this.score = undefined;
        // Create input and output nodes
        for (var i = 0; i &lt; inputSize; i++) {
            this.nodes.push(new Node_1.Node(NodeType_1.NodeType.INPUT));
        }
        for (var i = 0; i &lt; outputSize; i++) {
            this.nodes.push(new Node_1.Node(NodeType_1.NodeType.OUTPUT));
        }
        // Connect input and output nodes
        for (var i = 0; i &lt; this.inputSize; i++) {
            for (var j = this.inputSize; j &lt; this.outputSize + this.inputSize; j++) {
                // https://stats.stackexchange.com/a/248040/147931
                var weight = (Math.random() - 0.5) * this.inputSize * Math.sqrt(2 / this.inputSize);
                this.connect(this.nodes[i], this.nodes[j], weight);
            }
        }
    }
    /**
     * Convert a json object to a network
     *
     * @param {{input:{number},output:{number},dropout:{number},nodes:Array&lt;object>,connections:Array&lt;object>}} json A network represented as a json object
     *
     * @returns {Network} Network A reconstructed network
     *
     * @example
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * let exported = myNetwork.toJSON();
     * let imported = Network.fromJSON(exported) // imported will be a new instance of Network that is an exact clone of myNetwork
     */
    Network.fromJSON = function (json) {
        var network = new Network(json.inputSize, json.outputSize);
        network.nodes = [];
        network.connections = [];
        json.nodes.map(function (nodeJSON) { return new Node_1.Node().fromJSON(nodeJSON); }).forEach(function (node) { return network.nodes[node.index] = node; });
        json.connections.forEach(function (jsonConnection) {
            var connection = network.connect(network.nodes[jsonConnection.fromIndex], network.nodes[jsonConnection.toIndex], jsonConnection.weight);
            if (jsonConnection.gateNodeIndex != null) {
                network.addGate(network.nodes[jsonConnection.gateNodeIndex], connection);
            }
        });
        return network;
    };
    /**
     * Create an offspring from two parent networks.
     *
     * Networks are not required to have the same size, however input and output size should be the same!
     *
     * @todo Add custom [crossover](crossover) method customization
     *
     * @param {Network} network1 First parent network
     * @param {Network} network2 Second parent network
     * @param {boolean} [equal] Flag to indicate equally fit Networks
     *
     * @returns {Network} New network created from mixing parent networks
     */
    Network.crossOver = function (network1, network2, equal) {
        var _a, _b;
        if (network1.inputSize !== network2.inputSize || network1.outputSize !== network2.outputSize) {
            throw new Error("Networks don`t have the same input/output size!");
        }
        // Initialise offspring
        var offspring = new Network(network1.inputSize, network1.outputSize);
        offspring.connections = []; // clear
        offspring.nodes = []; // clear
        // Save scores and create a copy
        var score1 = (_a = network1.score) !== null &amp;&amp; _a !== void 0 ? _a : 0;
        var score2 = (_b = network2.score) !== null &amp;&amp; _b !== void 0 ? _b : 0;
        // Determine offspring node size
        var offspringSize;
        if (equal || score1 === score2) {
            var max = Math.max(network1.nodes.length, network2.nodes.length);
            var min = Math.min(network1.nodes.length, network2.nodes.length);
            offspringSize = Utils_1.randInt(min, max + 1); // [min,max]
        }
        else if (score1 > score2) {
            offspringSize = network1.nodes.length;
        }
        else {
            offspringSize = network2.nodes.length;
        }
        var inputSize = network1.inputSize;
        var outputSize = network1.outputSize;
        // set node indices
        for (var i = 0; i &lt; network1.nodes.length; i++) {
            network1.nodes[i].index = i;
        }
        // set node indices
        for (var i = 0; i &lt; network2.nodes.length; i++) {
            network2.nodes[i].index = i;
        }
        // Assign nodes from parents to offspring
        for (var i = 0; i &lt; offspringSize; i++) {
            var chosenNode = void 0;
            var chosenNodeType = null;
            // decide what type of node is needed first check for input and output nodes and fill up with hidden nodes
            if (i &lt; inputSize) { // pick input node
                chosenNodeType = NodeType_1.NodeType.INPUT;
                var sourceNetwork = Utils_1.randBoolean() ? network1 : network2;
                var inputNumber = -1;
                var j = -1;
                while (inputNumber &lt; i) {
                    if (j++ >= sourceNetwork.nodes.length) {
                        throw RangeError('something is wrong with the size of the input');
                    }
                    if (sourceNetwork.nodes[j].isInputNode()) {
                        inputNumber++;
                    }
                }
                chosenNode = sourceNetwork.nodes[j];
            }
            else if (i &lt; inputSize + outputSize) { // pick output node
                chosenNodeType = NodeType_1.NodeType.OUTPUT;
                var sourceNetwork = Utils_1.randBoolean() ? network1 : network2;
                var outputNumber = -1;
                var j = -1;
                while (outputNumber &lt; i - inputSize) {
                    j++;
                    if (j >= sourceNetwork.nodes.length) {
                        throw RangeError('something is wrong with the size of the output');
                    }
                    if (sourceNetwork.nodes[j].isOutputNode()) {
                        outputNumber++;
                    }
                }
                chosenNode = sourceNetwork.nodes[j];
            }
            else { // pick hidden node
                chosenNodeType = NodeType_1.NodeType.HIDDEN;
                var sourceNetwork = void 0;
                if (i >= network1.nodes.length) {
                    sourceNetwork = network2;
                }
                else if (i >= network2.nodes.length) {
                    sourceNetwork = network1;
                }
                else {
                    sourceNetwork = Utils_1.randBoolean() ? network1 : network2;
                }
                chosenNode = Utils_1.pickRandom(sourceNetwork.nodes);
            }
            var newNode = new Node_1.Node(chosenNodeType);
            newNode.bias = chosenNode.bias;
            newNode.squash = chosenNode.squash;
            offspring.nodes.push(newNode);
        }
        // Create arrays of connection genes
        var n1connections = [];
        var n2connections = [];
        // Add the connections of network 1
        network1.connections.forEach(function (connection) {
            n1connections[Connection_1.Connection.innovationID(connection.from.index, connection.to.index)] = connection.toJSON();
        });
        // Add the connections of network 2
        network2.connections.forEach(function (connection) {
            n2connections[Connection_1.Connection.innovationID(connection.from.index, connection.to.index)] = connection.toJSON();
        });
        // Split common conn genes from disjoint or excess conn genes
        var connections = [];
        var keys1 = Object.keys(n1connections);
        var keys2 = Object.keys(n2connections);
        for (var i = keys1.length - 1; i >= 0; i--) {
            if (n2connections[parseInt(keys1[i])] !== undefined) {
                connections.push(Utils_1.randBoolean() ? n1connections[parseInt(keys1[i])] : n2connections[parseInt(keys1[i])]);
                n2connections[parseInt(keys1[i])] = undefined;
            }
            else if (score1 >= score2 || equal) {
                connections.push(n1connections[parseInt(keys1[i])]);
            }
        }
        // Excess/disjoint gene
        if (score2 >= score1 || equal) {
            keys2
                .map(function (key) { return parseInt(key); }) // convert to numbers
                .map(function (key) { return n2connections[key]; }) // get the connection
                .filter(function (conn) { return conn !== undefined; }) // filter out undefined connections
                .forEach(function (conn) { return connections.push(conn); }); // add the filtered connections
        }
        // Add common conn genes uniformly
        connections.forEach(function (connectionJSON) {
            if (connectionJSON !== undefined &amp;&amp; connectionJSON.toIndex &lt; offspringSize &amp;&amp; connectionJSON.fromIndex &lt; offspringSize) {
                var from = offspring.nodes[connectionJSON.fromIndex];
                var to = offspring.nodes[connectionJSON.toIndex];
                var connection = offspring.connect(from, to, connectionJSON.weight);
                if (connectionJSON.gateNodeIndex !== null &amp;&amp; connectionJSON.gateNodeIndex &lt; offspringSize) {
                    offspring.addGate(offspring.nodes[connectionJSON.gateNodeIndex], connection);
                }
            }
        });
        return offspring;
    };
    /**
     * Returns a copy of Network.
     *
     * @returns {Network} Returns an identical network
     */
    Network.prototype.copy = function () {
        return Network.fromJSON(this.toJSON());
    };
    /**
     * Connects a Node to another Node or Group in the network
     *
     * @param {Node} from The source Node
     * @param {Node} to The destination Node or Group
     * @param {number} [weight=0] An initial weight for the connections to be formed
     *
     * @returns {Connection[]} An array of the formed connections
     *
     * @example
     * myNetwork.connect(myNetwork.nodes[4], myNetwork.nodes[5]); // connects network node 4 to network node 5
     */
    Network.prototype.connect = function (from, to, weight) {
        if (weight === void 0) { weight = 0; }
        var connection = from.connect(to, weight); // run node-level connect
        this.connections.push(connection); // add it to the array
        return connection;
    };
    /**
     * Activates the network
     *
     * It will activate all the nodes in activation order and produce an output.
     *
     * @param {number[]} [input] Input values to activate nodes with
     * @param options
     * @returns {number[]} Squashed output values
     *
     * @example
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * // Create a network
     * let myNetwork = new Network(3, 2);
     *
     * myNetwork.activate([0.8, 1, 0.21]); // gives: [0.49, 0.51]
     */
    Network.prototype.activate = function (input, options) {
        if (options === void 0) { options = {}; }
        if (input.length !== this.inputSize) {
            throw new RangeError("Input size of dataset is different to network input size!");
        }
        // get default value if no value is given
        options.dropoutRate = Utils_1.getOrDefault(options.dropoutRate, 0);
        options.trace = Utils_1.getOrDefault(options.trace, true);
        this.nodes
            .filter(function (node) { return node.isInputNode(); }) // only input nodes
            .forEach(function (node, index) { return node.activate(input[index], options.trace); }); // activate them with the input
        this.nodes
            .filter(function (node) { return node.isHiddenNode(); }) // only hidden nodes
            .forEach(function (node) {
            if (options.dropoutRate) {
                node.mask = Math.random() >= options.dropoutRate ? 1 : 0;
            }
            node.activate(undefined, options.trace); // activate them
        });
        return this.nodes
            .filter(function (node) { return node.isOutputNode(); }) // only output nodes
            .map(function (node) { return node.activate(undefined, options.trace); }); // map them to there activation value will give the network's output
    };
    /**
     * Backpropagate the network
     *
     * This function allows you to teach the network. If you want to do more complex training, use the `network.train()` function.
     *
     * @param {number[]} target Ideal values of the previous activate. Will use the difference to improve the weights
     * @param options More option for propagation
     *
     * @example
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * let myNetwork = new Network(1,1);
     *
     * // This trains the network to function as a NOT gate
     * for(let nodeIndex: number= 0; i &lt; 1000; i++){
     *  network.activate([0]);
     *  network.propagate(0.2, 0, true, [1]);
     *  network.activate([1]);
     *  network.propagate(0.3, 0, true, [0]);
     * }
     */
    Network.prototype.propagate = function (target, options) {
        if (options === void 0) { options = {}; }
        // get default value if value isn't given
        options.rate = Utils_1.getOrDefault(options.rate, 0.3);
        options.momentum = Utils_1.getOrDefault(options.momentum, 0);
        options.update = Utils_1.getOrDefault(options.update, false);
        if (target.length !== this.outputSize) {
            throw new Error("Output target length should match network output length");
        }
        // Backpropagation: output -> hidden -> input
        // propagate through the output nodes
        this.nodes
            .filter(function (node) { return node.isOutputNode(); }) // only output nodes
            .forEach(function (node, index) { return node.propagate(target[index], options); }); // propagate
        // propagate backwards through the hidden nodes
        for (var i = this.nodes.length - 1; i >= 0; i--) {
            if (this.nodes[i].isHiddenNode()) { // only hidden nodes
                this.nodes[i].propagate(undefined, options);
            }
        }
        // propagate through the input nodes
        this.nodes
            .filter(function (node) { return node.isInputNode(); }) // only input nodes
            .forEach(function (node) { return node.propagate(undefined, options); }); // propagate
    };
    /**
     * Clear the context of the network
     */
    Network.prototype.clear = function () {
        this.nodes.forEach(function (node) { return node.clear(); });
    };
    /**
     * Removes the connection of the `from` node to the `to` node
     *
     * @param {Node} from Source node
     * @param {Node} to Destination node
     *
     * @example
     * myNetwork.disconnect(myNetwork.nodes[4], myNetwork.nodes[5]);
     * // now node 4 does not have an effect on the output of node 5 anymore
     */
    Network.prototype.disconnect = function (from, to) {
        var _this = this;
        // remove the connection network-level
        this.connections
            .filter(function (conn) { return conn.from === from; }) // check for incoming node
            .filter(function (conn) { return conn.to === to; }) // check for outgoing node
            .forEach(function (conn) {
            if (conn.gateNode !== null) {
                _this.removeGate(conn); // remove possible gate
            }
            Utils_1.removeFromArray(_this.connections, conn); // remove connection from array
        });
        // disconnect node-level
        return from.disconnect(to);
    };
    /**
     * Makes a network node gate a connection
     *
     * @todo Add ability to gate several network connections at once
     *
     * @param {Node} node Gating node
     * @param {Connection} connection Connection to gate with node
     *
     * @example
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * myNetwork.gate(myNetwork.nodes[1], myNetwork.connections[5])
     * // now: connection 5's weight is multiplied with node 1's activation
     */
    Network.prototype.addGate = function (node, connection) {
        if (this.nodes.indexOf(node) === -1) {
            throw new ReferenceError("This node is not part of the network!");
        }
        else if (connection.gateNode != null) {
            return;
        }
        node.addGate(connection);
        this.gates.push(connection);
    };
    /**
     * Remove the gate of a connection.
     *
     * @param {Connection} connection Connection to remove gate from
     */
    Network.prototype.removeGate = function (connection) {
        if (!this.gates.includes(connection)) {
            throw new Error("This connection is not gated!");
        }
        Utils_1.removeFromArray(this.gates, connection);
        if (connection.gateNode != null) {
            connection.gateNode.removeGate(connection);
        }
    };
    /**
     * Removes a node from a network, all its connections will be redirected. If it gates a connection, the gate will be removed.
     *
     * @param {Node} node Node to remove from the network
     * @param keepGates
     */
    Network.prototype.removeNode = function (node, keepGates) {
        var _this = this;
        if (keepGates === void 0) { keepGates = new Mutation_1.SubNodeMutation().keepGates; }
        if (!this.nodes.includes(node)) {
            throw new ReferenceError("This node does not exist in the network!");
        }
        this.disconnect(node, node); // remove self connection
        var inputs = []; // keep track
        var gates = []; // keep track
        var outputs = []; // keep track
        var connections = []; // keep track
        // read all inputs from node and keep track of the nodes that gate the incoming connection
        for (var i = node.incoming.length - 1; i >= 0; i--) {
            var connection = node.incoming[i];
            if (keepGates &amp;&amp; connection.gateNode !== null &amp;&amp; connection.gateNode !== node) {
                gates.push(connection.gateNode);
            }
            inputs.push(connection.from);
            this.disconnect(connection.from, node);
        }
        // read all outputs from node and keep track of the nodes that gate the outgoing connection
        for (var i = node.outgoing.length - 1; i >= 0; i--) {
            var connection = node.outgoing[i];
            if (keepGates &amp;&amp; connection.gateNode !== null &amp;&amp; connection.gateNode !== node) {
                gates.push(connection.gateNode);
            }
            outputs.push(connection.to);
            this.disconnect(node, connection.to);
        }
        // add all connections the node has
        inputs.forEach(function (input) {
            outputs.forEach(function (output) {
                if (!input.isProjectingTo(output)) {
                    connections.push(_this.connect(input, output));
                }
            });
        });
        // as long as there are gates and connections
        while (gates.length > 0 &amp;&amp; connections.length > 0) {
            var gate = gates.shift(); // take a gate node and remove it from the array
            if (gate === undefined) {
                continue;
            }
            var connection = Utils_1.pickRandom(connections); // take a random connection
            this.addGate(gate, connection); // gate the connection with the gate node
            Utils_1.removeFromArray(connections, connection); // remove the connection from the array
        }
        // remove every gate the node has
        for (var i = node.gated.length - 1; i >= 0; i--) {
            this.removeGate(node.gated[i]);
        }
        Utils_1.removeFromArray(this.nodes, node); // remove the node from the nodes array
    };
    /**
     * Mutates the network with the given method.
     *
     * @param {Mutation} method [Mutation method](mutation)
     * @param {object} options
     * @param {number} [options.maxNodes]
     * @param {number} [options.maxConnections]
     * @param {number} [options.maxGates] Maximum amount of Gates a network can grow to
     *
     * @example
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * myNetwork = myNetwork.mutate(new AddNodeMutation()) // returns a mutated network with an added gate
     */
    Network.prototype.mutate = function (method, options) {
        method.mutate(this, options);
    };
    /**
     * Selects a random mutation method and returns a mutated copy of the network. Warning! Mutates network directly.
     *
     * @param {Mutation[]} [allowedMethods=methods.mutation.ALL] An array of [Mutation methods](mutation) to automatically pick from
     * @param {object} options
     * @param {number} [options.maxNodes] Maximum amount of [Nodes](node) a network can grow to
     * @param {number} [options.maxConnections] Maximum amount of [Connections](connection) a network can grow to
     * @param {number} [options.maxGates] Maximum amount of Gates a network can grow to
     */
    Network.prototype.mutateRandom = function (allowedMethods, options) {
        if (allowedMethods === void 0) { allowedMethods = Mutation_1.ALL_MUTATIONS; }
        if (options === void 0) { options = {}; }
        if (allowedMethods.length === 0) {
            return;
        }
        // mutate the network with a random allowed mutation
        this.mutate(Utils_1.pickRandom(allowedMethods), options);
    };
    /**
     * Train the given data to this network
     *
     * @param {TrainOptions} options Options used to train network
     * @param {Array&lt;{input:number[],output:number[]}>} options.data A data of input values and ideal output values to train the network with
     * @param {options.loss} [options.loss=new MSELoss()] The [options.loss function](https://en.wikipedia.org/wiki/Loss_function) used to determine network error
     * @param {rate} [options.ratePolicy=new FixedRate(options.rate)] A [learning rate policy](https://towardsdatascience.com/understanding-learning-rates-and-how-it-improves-performance-in-deep-learning-d0d4059c1c10), i.e. how to change the learning rate during training to get better network performance
     * @param {number} [options.rate=0.3] Sets the [learning rate](https://towardsdatascience.com/understanding-learning-rates-and-how-it-improves-performance-in-deep-learning-d0d4059c1c10) of the backpropagation process
     * @param {number} [options.iterations=1000] Sets amount of training cycles the process will maximally run, even when the target error has not been reached.
     * @param {number} [options.error] The target error to train for, once the network falls below this error, the process is stopped. Lower error rates require more training cycles.
     * @param {number} [options.dropout=0] [Dropout rate](https://medium.com/@amarbudhiraja/https-medium-com-amarbudhiraja-learning-less-to-learn-better-options.dropout-in-deep-machine-learning-74334da4bfc5) likelihood for any given neuron to be ignored during network training. Must be between zero and one, numbers closer to one will result in more neurons ignored.
     * @param {number} [options.momentum=0] [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html). Adds a fraction of the previous weight update to the current one.
     * @param {number} [options.batchSize=1] Sets the (mini-) batch size of your training. Default: 1 [(online training)](https://www.quora.com/What-is-the-difference-between-batch-online-and-mini-batch-training-in-neural-networks-Which-one-should-I-use-for-a-small-to-medium-sized-dataset-for-prediction-purposes)
     * @param {number} [options.crossValidate.testSize] Sets the amount of test cases that should be assigned to cross validation. If data to 0.4, 40% of the given data will be used for cross validation.
     * @param {number} [options.crossValidate.testError] Sets the target error of the validation data.
     * @param {boolean} [options.clear=false] If set to true, will clear the network after every activation. This is useful for training LSTM's, more importantly for time series prediction.
     * @param {boolean} [options.shuffle=false] When set to true, will shuffle the training data every iterationNumber. Good option to use if the network is performing worse in [cross validation](https://artint.info/html/ArtInt_189.html) than in the real training data.
     * @param {number|boolean} [options.log=false] If set to n, outputs training status every n iterations. Setting `log` to 1 will log the status every iteration_number
     * @param {number} [options.schedule.iterations] You can schedule tasks to happen every n iterations. Paired with `options.schedule.function`
     * @param {schedule} [options.schedule.function] A function to run every n iterations as data by `options.schedule.iterations`. Passed as an object with a "function" property that contains the function to run.
     *
     * @returns {{error:{number},iterations:{number},time:{number}}} A summary object of the network's performance
     *
     * @example &lt;caption>Training with Defaults&lt;/caption>
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * let network = new Network(2, 1);
     *
     * // Train the XOR gate
     * network.train([{ input: [0,0], output: [0] },
     *                { input: [0,1], output: [1] },
     *                { input: [1,0], output: [1] },
     *                { input: [1,1], output: [0] }]);
     *
     * network.activate([0,1]); // 0.9824...
     *
     * @example &lt;caption>Training with Options&lt;/caption>
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * let network = new Network(2, 1);
     *
     * let trainingSet = [
     *    { input: [0,0], output: [0] },
     *    { input: [0,1], output: [1] },
     *    { input: [1,0], output: [1] },
     *    { input: [1,1], output: [0] }
     * ];
     *
     * // Train the XNOR gate
     * network.train(trainingSet, {
     *    log: 1,
     *    iterations: 1000,
     *    error: 0.0001,
     *    rate: 0.2
     * });
     *
     * @example &lt;caption>Cross Validation Example&lt;/caption>
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * let network = new Network(2,1);
     *
     * let trainingSet = [ // PS: don't use cross validation for small sets, this is just an example
     *  { input: [0,0], output: [1] },
     *  { input: [0,1], output: [0] },
     *  { input: [1,0], output: [0] },
     *  { input: [1,1], output: [1] }
     * ];
     *
     * // Train the XNOR gate
     * network.train(trainingSet, {
     *  crossValidate:
     *    {
     *      testSize: 0.4,
     *      testError: 0.02
     *    }
     * });
     *
     */
    Network.prototype.train = function (options) {
        var _a;
        if (!options.dataset || options.dataset[0].input.length !== this.inputSize || options.dataset[0].output.length !== this.outputSize) {
            throw new Error("Dataset input/output size should be same as network input/output size!");
        }
        // Use the default values, if no value is given
        options.iterations = Utils_1.getOrDefault(options.iterations, -1);
        options.error = Utils_1.getOrDefault(options.error, -1);
        options.loss = Utils_1.getOrDefault(options.loss, new Loss_1.MSELoss());
        options.dropout = Utils_1.getOrDefault(options.dropout, 0);
        options.momentum = Utils_1.getOrDefault(options.momentum, 0);
        options.batchSize = Math.min(options.dataset.length, Utils_1.getOrDefault(options.batchSize, options.dataset.length));
        var baseRate = Utils_1.getOrDefault(options.rate, 0.3);
        options.ratePolicy = Utils_1.getOrDefault(options.ratePolicy, new Rate_1.FixedRate(baseRate));
        options.log = Utils_1.getOrDefault(options.log, NaN);
        var start = Date.now();
        if (options.iterations &lt;= 0 &amp;&amp; options.error &lt;= 0) {
            throw new Error("At least one of the following options must be specified: error, iterations");
        }
        // Split into trainingSet and testSet if cross validation is enabled
        var trainingSetSize;
        var trainingSet;
        var testSet;
        if (options.crossValidateTestSize &amp;&amp; options.crossValidateTestSize > 0) {
            trainingSetSize = Math.ceil((1 - options.crossValidateTestSize) * options.dataset.length);
            trainingSet = options.dataset.slice(0, trainingSetSize);
            testSet = options.dataset.slice(trainingSetSize);
        }
        else {
            trainingSet = options.dataset;
            testSet = [];
        }
        var currentTrainingRate;
        var iterationCount = 0;
        var error = 1;
        // train until the target error is reached or the target iterations are reached
        while (error > options.error &amp;&amp; (options.iterations &lt;= 0 || iterationCount &lt; options.iterations)) {
            iterationCount++;
            // update the rate according to the rate policy
            currentTrainingRate = options.ratePolicy.calc(iterationCount);
            // train a single epoch
            var trainError = this.trainEpoch(trainingSet, options.batchSize, currentTrainingRate, options.momentum, options.loss, options.dropout);
            if (options.clear) {
                this.clear();
            }
            // Run test with the testSet, if cross validation is enabled
            if (options.crossValidateTestSize) {
                error = this.test(testSet, options.loss);
                if (options.clear) {
                    this.clear();
                }
            }
            else {
                error = trainError;
            }
            if ((_a = options.shuffle) !== null &amp;&amp; _a !== void 0 ? _a : false) {
                Utils_1.shuffle(options.dataset);
            }
            if (options.log > 0 &amp;&amp; iterationCount % options.log === 0) {
                console.log("iteration number", iterationCount, "error", error, "training rate", currentTrainingRate);
            }
            if (options.schedule &amp;&amp; iterationCount % options.schedule.iterations === 0) {
                options.schedule.function(error, iterationCount);
            }
        }
        if (options.clear) {
            this.clear();
        }
        return {
            error: error,
            iterations: iterationCount,
            time: Date.now() - start
        };
    };
    /**
     * Performs one training epoch and returns the error - this is a private function used in `self.train`
     *
     * @todo Add `@param` tag descriptions
     * @todo Add `@returns` tag description
     *
     * @private
     *
     * @param {Array&lt;{input:number[], output: number[]}>} dataset
     * @param {number} batchSize
     * @param {number} trainingRate
     * @param {number} momentum
     * @param {loss} loss
     * @param {number} dropoutRate=0.5 The dropout rate to use when training
     *
     * @returns {number}
     */
    Network.prototype.trainEpoch = function (dataset, batchSize, trainingRate, momentum, loss, dropoutRate) {
        if (dropoutRate === void 0) { dropoutRate = 0.5; }
        var errorSum = 0;
        for (var i = 0; i &lt; dataset.length; i++) {
            var input = dataset[i].input;
            var correctOutput = dataset[i].output;
            var update = (i + 1) % batchSize === 0 || i + 1 === dataset.length;
            var output = this.activate(input, { dropoutRate: dropoutRate });
            this.propagate(correctOutput, { rate: trainingRate, momentum: momentum, update: update });
            errorSum += loss.calc(correctOutput, output);
        }
        return errorSum / dataset.length;
    };
    /**
     * Tests a set and returns the error and elapsed time
     *
     * @param {Array&lt;{input:number[],output:number[]}>} dataset A set of input values and ideal output values to test the network against
     * @param {Loss} [loss=new MSELoss()] The [loss function](https://en.wikipedia.org/wiki/Loss_function) used to determine network error
     *
     * @returns {number} A summary object of the network's performance
     */
    Network.prototype.test = function (dataset, loss) {
        if (loss === void 0) { loss = new Loss_1.MSELoss(); }
        var error = 0;
        for (var _i = 0, dataset_1 = dataset; _i &lt; dataset_1.length; _i++) {
            var entry = dataset_1[_i];
            var input = entry.input;
            var target = entry.output;
            var output = this.activate(input, { trace: false });
            error += loss.calc(target, output);
        }
        return error / dataset.length;
    };
    /**
     * Convert the network to a json object
     *
     * @returns {NetworkJSON} The network represented as a json object
     *
     * @example
     * let { Network } = require("@liquid-carrot/carrot");
     *
     * let exported = myNetwork.toJSON();
     * let imported = Network.fromJSON(exported) // imported will be a new instance of Network that is an exact clone of myNetwork
     */
    Network.prototype.toJSON = function () {
        var json = {
            nodes: [],
            connections: [],
            inputSize: this.inputSize,
            outputSize: this.outputSize,
        };
        // set node indices
        for (var i = 0; i &lt; this.nodes.length; i++) {
            this.nodes[i].index = i;
        }
        // convert all nodes to json and add the to the json object
        this.nodes.forEach(function (node) {
            json.nodes.push(node.toJSON());
            if (node.selfConnection.weight !== 0) {
                // if there is a self connection
                // add it to the json object
                json.connections.push(node.selfConnection.toJSON());
            }
        });
        this.connections
            .map(function (conn) { return conn.toJSON(); }) // convert all connections to json
            .forEach(function (connJSON) { return json.connections.push(connJSON); }); // and add them to the json object
        return json;
    };
    /**
     * Evolves the network to reach a lower error on a dataset using the [NEAT algorithm](http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf)
     *
     * If both `iterations` and `error` options are unset, evolve will default to `iterations` as an end condition.
     * @param {object} [options] Configuration options
     * @param {Array&lt;{input:number[],output:number[]}>} [options.dataset] A set of input values and ideal output values to train the network with
     * @param {number} [options.iterations=1000] Set the maximum amount of iterations/generations for the algorithm to run.
     * @param {number} [options.error=0.05] Set the target error. The algorithm will stop once this target error has been reached.
     * @param {number} [options.growth=0.0001] Set the penalty for large networks. Penalty calculation: penalty = (genome.nodes.length + genome.connections.length + genome.gates.length) * growth; This penalty will get added on top of the error. Your growth should be a very small number.
     * @param {loss} [options.loss=loss.MSE]  Specify the loss function for the evolution, this tells a genome in the population how well it's performing. Default: methods.loss.MSE (recommended).
     * @param {number} [options.amount=1] Set the amount of times to test the trainingSet on a genome each generation. Useful for time series. Do not use for regular feed forward problems.
     * @param {number} [options.threads] Specify the amount of threads to use. Default value is the amount of cores in your CPU.
     * @param {Network} [options.network]
     * @param {number|boolean} [options.log=false] If set to n, outputs training status every n iterations. Setting `log` to 1 will log the status every iteration
     * @param {number} [options.schedule.iterations] You can schedule tasks to happen every n iterations. Paired with `options.schedule.function`
     * @param {schedule} [options.schedule.function] A function to run every n iterations as set by `options.schedule.iterations`. Passed as an object with a "function" property that contains the function to run.
     * @param {boolean} [options.clear=false] If set to true, will clear the network after every activation. This is useful for evolving recurrent networks, more importantly for time series prediction.
     * @param {boolean} [options.equal=true] If set to true when [Network.crossOver](Network.crossOver) runs it will assume both genomes are equally fit.
     * @param {number} [options.populationSize=50] Population size of each generation.
     * @param {number} [options.elitism=1] Elitism of every evolution loop. [Elitism in genetic algorithms.](https://www.researchgate.net/post/What_is_meant_by_the_term_Elitism_in_the_Genetic_Algorithm)
     * @param {number} [options.provenance=0] Number of genomes inserted into the original network template (Network(input,output)) per evolution.
     * @param {number} [options.mutationRate=0.4] Sets the mutation rate. If set to 0.3, 30% of the new population will be mutated.
     * @param {number} [options.mutationAmount=1] If mutation occurs (randomNumber &lt; mutationRate), sets amount of times a mutation method will be applied to the network.
     * @param {boolean} [options.fitnessPopulation=true] Flag to return the fitness of a population of genomes. false => evaluate each genome individually. true => evaluate entire population. Adjust fitness function accordingly
     * @param {Function} [options.fitness] - A fitness function to evaluate the networks. Takes a `genome`, i.e. a [network](Network), and a `dataset` and sets the genome's score property
     * @param {string} [options.selection=new FitnessProportionateSelection()] [Selection method](selection) for evolution (e.g. methods.Selection.FITNESS_PROPORTIONATE).
     * @param {Array} [options.crossover] Sets allowed crossover methods for evolution.
     * @param {Array} [options.mutation] Sets allowed [mutation methods](mutation) for evolution, a random mutation method will be chosen from the array when mutation occurs. Optional, but default methods are non-recurrent.
     * @param {number} [options.maxNodes=Infinity] Maximum nodes for a potential network
     * @param {number} [options.maxConnections=Infinity] Maximum connections for a potential network
     * @param {number} [options.maxGates=Infinity] Maximum gates for a potential network
     * @param {function} [options.mutationSelection=random] Custom mutation selection function if given
     * @param {boolean} [options.efficientMutation=false] Test &amp; reduce [mutation methods](mutation) to avoid failed mutation attempts
     *
     * @returns {{error:{number},iterations:{number},time:{number}}} A summary object of the network's performance. &lt;br /> Properties include: `error` - error of the best genome, `iterations` - generations used to evolve networks, `time` - clock time elapsed while evolving
     *
     * @example
     * let { Network, methods } = require("@liquid-carrot/carrot");
     *
     * async function execute () {
     *    var network = new Network(2,1);
     *
     *    // XOR dataset
     *    var trainingSet = [
     *        { input: [0,0], output: [0] },
     *        { input: [0,1], output: [1] },
     *        { input: [1,0], output: [1] },
     *        { input: [1,1], output: [0] }
     *    ];
     *
     *    await network.evolve(trainingSet, {
     *        mutation: methods.mutation.FFW,
     *        equal: true,
     *        error: 0.05,
     *        elitism: 5,
     *        mutationRate: 0.5
     *    });
     *
     *    // another option
     *    // await network.evolve(trainingSet, {
     *    //     mutation: methods.mutation.FFW,
     *    //     equal: true,
     *    //     error: 0.05,
     *    //     elitism: 5,
     *    //     mutationRate: 0.5,
     *    //     loss: (targets, outputs) => {
     *    //       const error = outputs.reduce(function(total, value, index) {
     *    //         return total += Math.pow(targets[index] - outputs[index], 2);
     *    //       }, 0);
     *    //
     *    //       return error / outputs.length;
     *    //     }
     *    // });
     *
     *
     *    network.activate([0,0]); // 0.2413
     *    network.activate([0,1]); // 1.0000
     *    network.activate([1,0]); // 0.7663
     *    network.activate([1,1]); // -0.008
     * }
     *
     * execute();
     */
    Network.prototype.evolve = function (options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var targetError, start, neat, error, bestFitness, bestGenome, fittest, fitness;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!options.fitnessFunction &amp;&amp; options.dataset &amp;&amp; (options.dataset[0].input.length !== this.inputSize || options.dataset[0].output.length !== this.outputSize)) {
                            throw new Error("Dataset input/output size should be same as network input/output size!");
                        }
                        targetError = 0;
                        if (typeof options.iterations === "undefined" &amp;&amp; typeof options.error === "undefined") {
                            options.iterations = 1000;
                            targetError = 0.05;
                        }
                        else if (options.iterations) {
                            targetError = -1; // run until iterations
                        }
                        else if (options.error) {
                            targetError = options.error;
                            options.iterations = 0; // run until error
                        }
                        // set options to default if necessary
                        options.growth = Utils_1.getOrDefault(options.growth, 0.0001);
                        options.loss = Utils_1.getOrDefault(options.loss, new Loss_1.MSELoss());
                        options.maxNodes = Utils_1.getOrDefault(options.maxNodes, Infinity);
                        options.maxConnections = Utils_1.getOrDefault(options.maxConnections, Infinity);
                        options.maxGates = Utils_1.getOrDefault(options.maxGates, Infinity);
                        start = Date.now();
                        if (!options.fitnessFunction) {
                            // if no fitness function is given
                            // create default one
                            options.fitnessFunction = function (population) {
                                return __awaiter(this, void 0, void 0, function () {
                                    var promises, _loop_1, _i, population_1, genome;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                promises = [];
                                                _loop_1 = function (genome) {
                                                    promises.push(new Promise((function (resolve, reject) {
                                                        var _a, _b;
                                                        if (!genome || !options.dataset) {
                                                            reject();
                                                            return;
                                                        }
                                                        // test the genome
                                                        genome.score = -genome.test(options.dataset, (_a = options.loss) !== null &amp;&amp; _a !== void 0 ? _a : new Loss_1.MSELoss());
                                                        if (genome.score === undefined) {
                                                            genome.score = -Infinity;
                                                            return;
                                                        }
                                                        // subtract growth value
                                                        genome.score -= ((_b = options.growth) !== null &amp;&amp; _b !== void 0 ? _b : 0.0001) * (genome.nodes.length
                                                            - genome.inputSize
                                                            - genome.outputSize
                                                            + genome.connections.length
                                                            + genome.gates.length);
                                                        resolve();
                                                    })));
                                                };
                                                for (_i = 0, population_1 = population; _i &lt; population_1.length; _i++) {
                                                    genome = population_1[_i];
                                                    _loop_1(genome);
                                                }
                                                return [4 /*yield*/, Promise.all(promises)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/];
                                        }
                                    });
                                });
                            };
                        }
                        options.template = this; // set this network as template for first generation
                        neat = new NEAT_1.NEAT(options);
                        error = -Infinity;
                        bestFitness = -Infinity;
                        _e.label = 1;
                    case 1:
                        if (!(error &lt; -targetError &amp;&amp; (options.iterations === 0 || neat.generation &lt; ((_a = options.iterations) !== null &amp;&amp; _a !== void 0 ? _a : 0)))) return [3 /*break*/, 3];
                        return [4 /*yield*/, neat.evolve()];
                    case 2:
                        fittest = _e.sent();
                        fitness = (_b = fittest.score) !== null &amp;&amp; _b !== void 0 ? _b : -Infinity;
                        // add the growth value back to get the real error
                        error = fitness + options.growth * (fittest.nodes.length
                            - fittest.inputSize
                            - fittest.outputSize
                            + fittest.connections.length
                            + fittest.gates.length);
                        if (fitness > bestFitness) {
                            bestFitness = fitness;
                            bestGenome = fittest;
                        }
                        if (((_c = options.log) !== null &amp;&amp; _c !== void 0 ? _c : 0) > 0 &amp;&amp; neat.generation % ((_d = options.log) !== null &amp;&amp; _d !== void 0 ? _d : 0) === 0) {
                            console.log("iteration", neat.generation, "fitness", fitness, "error", -error);
                        }
                        if (options.schedule &amp;&amp; neat.generation % options.schedule.iterations === 0) {
                            options.schedule.function(fitness, -error, neat.generation);
                        }
                        return [3 /*break*/, 1];
                    case 3:
                        if (bestGenome !== undefined) {
                            // set this network to the fittest from NEAT
                            this.nodes = bestGenome.nodes;
                            this.connections = bestGenome.connections;
                            this.gates = bestGenome.gates;
                            if (options.clear) {
                                this.clear();
                            }
                        }
                        return [2 /*return*/, {
                                error: -error,
                                iterations: neat.generation,
                                time: Date.now() - start,
                            }];
                }
            });
        });
    };
    return Network;
}());
exports.Network = Network;
</code></pre>
        </article>
    </section>





            

        </div>
        <div class="column is-hidden-touch"></div>
    </div>
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Tue May 12 2020 21:51:13 GMT+0200 (GMT+02:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>




<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
  heap.load("1195922815");
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {

  // Get all "navbar-burger" elements
  const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

  // Check if there are any navbar burgers
  if ($navbarBurgers.length > 0) {

    // Add a click event on each of them
    $navbarBurgers.forEach( el => {
      el.addEventListener('click', () => {

        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');

      });
    });
  }

});
</script>
<script src="scripts/clipboard.min.js"></script>
<script>
  // example copying functionality
  const clipboard = new ClipboardJS('code');
  const clipboard_button = new ClipboardJS('.copy-button');

  clipboard_button.on('success', (e) => {
    e.trigger.innerText = "Copied!"
  });

  const copy_buttons = document.querySelectorAll(".copy-button");
  
  copy_buttons.forEach(function(btn) {
    btn.addEventListener("mouseout", function(e) {
      setTimeout(function() {
        e.fromElement.innerText = "Copy"
      }, 200);
    });
  });
</script>
<script>prettyPrint();</script>
</body>
</html>
