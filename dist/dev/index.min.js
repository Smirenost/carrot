(function () {
// ASSET: architecture\layer\Layer.js
var $EX0Z$exports = {};
Object.defineProperty($EX0Z$exports, "__esModule", {
  value: true
});

var $EX0Z$var$Layer =
/** @class */
function () {
  function Layer(inputSize, outputSize) {
    this.inputSize = inputSize;
    this.outputSize = outputSize;
    this.nodes = [];
    this.connections = [];
  }

  return Layer;
}();

var $EX0Z$export$Layer = $EX0Z$var$Layer;
$EX0Z$exports.Layer = $EX0Z$export$Layer;
// ASSET: architecture\layer\ConvolutionLayer.js
var $StXe$exports = {};

var $StXe$var$__extends = $StXe$exports && $StXe$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($StXe$exports, "__esModule", {
  value: true
});

var $StXe$var$ConvolutionLayer =
/** @class */
function (_super) {
  $StXe$var$__extends(ConvolutionLayer, _super);

  function ConvolutionLayer(inputSize, outputSize) {
    return _super.call(this, inputSize, outputSize) || this;
  }

  return ConvolutionLayer;
}($EX0Z$export$Layer);

var $StXe$export$ConvolutionLayer = $StXe$var$ConvolutionLayer;
$StXe$exports.ConvolutionLayer = $StXe$export$ConvolutionLayer;
// ASSET: methods\Activation.js
var $HKRw$export$ActivationType,
    $HKRw$exports = {};
Object.defineProperty($HKRw$exports, "__esModule", {
  value: true
});

var $HKRw$var$Activation =
/** @class */
function () {
  function Activation() {
    this.type = $HKRw$var$ActivationType.NO_ACTIVATION;
  }

  Activation.getActivation = function (activationType) {
    switch (activationType) {
      case $HKRw$var$ActivationType.LogisticActivation:
        return new $HKRw$var$LogisticActivation();

      case $HKRw$var$ActivationType.TanhActivation:
        return new $HKRw$var$TanhActivation();

      case $HKRw$var$ActivationType.IdentityActivation:
        return new $HKRw$var$IdentityActivation();

      case $HKRw$var$ActivationType.StepActivation:
        return new $HKRw$var$StepActivation();

      case $HKRw$var$ActivationType.RELUActivation:
        return new $HKRw$var$RELUActivation();

      case $HKRw$var$ActivationType.SoftsignActivation:
        return new $HKRw$var$SoftsignActivation();

      case $HKRw$var$ActivationType.SinusoidActivation:
        return new $HKRw$var$LogisticActivation();

      case $HKRw$var$ActivationType.GaussianActivation:
        return new $HKRw$var$GaussianActivation();

      case $HKRw$var$ActivationType.BentIdentityActivation:
        return new $HKRw$var$BentIdentityActivation();

      case $HKRw$var$ActivationType.BipolarActivation:
        return new $HKRw$var$BipolarActivation();

      case $HKRw$var$ActivationType.BipolarSigmoidActivation:
        return new $HKRw$var$BipolarSigmoidActivation();

      case $HKRw$var$ActivationType.HardTanhActivation:
        return new $HKRw$var$HardTanhActivation();

      case $HKRw$var$ActivationType.AbsoluteActivation:
        return new $HKRw$var$AbsoluteActivation();

      case $HKRw$var$ActivationType.InverseActivation:
        return new $HKRw$var$InverseActivation();

      case $HKRw$var$ActivationType.SELUActivation:
        return new $HKRw$var$SELUActivation();
    }

    throw new ReferenceError(activationType + " is not the name of any available activations! These are all available activations: " + $HKRw$export$ALL_ACTIVATIONS);
  };

  return Activation;
}();

var $HKRw$export$Activation = $HKRw$var$Activation;
$HKRw$exports.Activation = $HKRw$export$Activation;

var $HKRw$var$LogisticActivation =
/** @class */
function () {
  function LogisticActivation() {
    this.type = $HKRw$var$ActivationType.LogisticActivation;
  }

  LogisticActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return 1 / (1 + Math.exp(-x));
    } else {
      return this.calc(x, false) * (1 - this.calc(x, false));
    }
  };

  return LogisticActivation;
}();

var $HKRw$export$LogisticActivation = $HKRw$var$LogisticActivation;
$HKRw$exports.LogisticActivation = $HKRw$export$LogisticActivation;

var $HKRw$var$TanhActivation =
/** @class */
function () {
  function TanhActivation() {
    this.type = $HKRw$var$ActivationType.TanhActivation;
  }

  TanhActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return Math.tanh(x);
    } else {
      return 1 - this.calc(x, false) * this.calc(x, false);
    }
  };

  return TanhActivation;
}();

var $HKRw$export$TanhActivation = $HKRw$var$TanhActivation;
$HKRw$exports.TanhActivation = $HKRw$export$TanhActivation;

var $HKRw$var$IdentityActivation =
/** @class */
function () {
  function IdentityActivation() {
    this.type = $HKRw$var$ActivationType.IdentityActivation;
  }

  IdentityActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return x;
    } else {
      return 1;
    }
  };

  return IdentityActivation;
}();

var $HKRw$export$IdentityActivation = $HKRw$var$IdentityActivation;
$HKRw$exports.IdentityActivation = $HKRw$export$IdentityActivation;

var $HKRw$var$StepActivation =
/** @class */
function () {
  function StepActivation() {
    this.type = $HKRw$var$ActivationType.StepActivation;
  }

  StepActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return x < 0 ? 0 : 1;
    } else {
      return 0;
    }
  };

  return StepActivation;
}();

var $HKRw$export$StepActivation = $HKRw$var$StepActivation;
$HKRw$exports.StepActivation = $HKRw$export$StepActivation;

var $HKRw$var$RELUActivation =
/** @class */
function () {
  function RELUActivation() {
    this.type = $HKRw$var$ActivationType.RELUActivation;
  }

  RELUActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return x <= 0 ? 0 : x;
    } else {
      return x <= 0 ? 0 : 1;
    }
  };

  return RELUActivation;
}();

var $HKRw$export$RELUActivation = $HKRw$var$RELUActivation;
$HKRw$exports.RELUActivation = $HKRw$export$RELUActivation;

var $HKRw$var$SoftsignActivation =
/** @class */
function () {
  function SoftsignActivation() {
    this.type = $HKRw$var$ActivationType.SoftsignActivation;
  }

  SoftsignActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return x / (1 + Math.abs(x));
    } else {
      return x / ((1 + Math.abs(x)) * (1 + Math.abs(x)));
    }
  };

  return SoftsignActivation;
}();

var $HKRw$export$SoftsignActivation = $HKRw$var$SoftsignActivation;
$HKRw$exports.SoftsignActivation = $HKRw$export$SoftsignActivation;

var $HKRw$var$SinusoidActivation =
/** @class */
function () {
  function SinusoidActivation() {
    this.type = $HKRw$var$ActivationType.SinusoidActivation;
  }

  SinusoidActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return Math.sin(x);
    } else {
      return Math.cos(x);
    }
  };

  return SinusoidActivation;
}();

var $HKRw$export$SinusoidActivation = $HKRw$var$SinusoidActivation;
$HKRw$exports.SinusoidActivation = $HKRw$export$SinusoidActivation;

var $HKRw$var$GaussianActivation =
/** @class */
function () {
  function GaussianActivation() {
    this.type = $HKRw$var$ActivationType.GaussianActivation;
  }

  GaussianActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return Math.exp(-x * x);
    } else {
      return -2 * x * this.calc(x, false);
    }
  };

  return GaussianActivation;
}();

var $HKRw$export$GaussianActivation = $HKRw$var$GaussianActivation;
$HKRw$exports.GaussianActivation = $HKRw$export$GaussianActivation;

var $HKRw$var$BentIdentityActivation =
/** @class */
function () {
  function BentIdentityActivation() {
    this.type = $HKRw$var$ActivationType.BentIdentityActivation;
  }

  BentIdentityActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return (Math.sqrt(x * x + 1) - 1) / 2 + x;
    } else {
      return x / (2 * Math.sqrt(x * x + 1)) + 1;
    }
  };

  return BentIdentityActivation;
}();

var $HKRw$export$BentIdentityActivation = $HKRw$var$BentIdentityActivation;
$HKRw$exports.BentIdentityActivation = $HKRw$export$BentIdentityActivation;

var $HKRw$var$BipolarActivation =
/** @class */
function () {
  function BipolarActivation() {
    this.type = $HKRw$var$ActivationType.BipolarActivation;
  }

  BipolarActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return x > 0 ? 1 : -1;
    } else {
      return 0;
    }
  };

  return BipolarActivation;
}();

var $HKRw$export$BipolarActivation = $HKRw$var$BipolarActivation;
$HKRw$exports.BipolarActivation = $HKRw$export$BipolarActivation;

var $HKRw$var$BipolarSigmoidActivation =
/** @class */
function () {
  function BipolarSigmoidActivation() {
    this.type = $HKRw$var$ActivationType.BipolarSigmoidActivation;
  }

  BipolarSigmoidActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return 2 / (1 + Math.exp(-x)) - 1;
    } else {
      return 2 * Math.exp(-x) / ((1 + Math.exp(-x)) * (1 + Math.exp(-x)));
    }
  };

  return BipolarSigmoidActivation;
}();

var $HKRw$export$BipolarSigmoidActivation = $HKRw$var$BipolarSigmoidActivation;
$HKRw$exports.BipolarSigmoidActivation = $HKRw$export$BipolarSigmoidActivation;

var $HKRw$var$HardTanhActivation =
/** @class */
function () {
  function HardTanhActivation() {
    this.type = $HKRw$var$ActivationType.HardTanhActivation;
  }

  HardTanhActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return Math.max(-1, Math.min(1, x));
    } else {
      return Math.abs(x) < 1 ? 1 : 0;
    }
  };

  return HardTanhActivation;
}();

var $HKRw$export$HardTanhActivation = $HKRw$var$HardTanhActivation;
$HKRw$exports.HardTanhActivation = $HKRw$export$HardTanhActivation;

var $HKRw$var$AbsoluteActivation =
/** @class */
function () {
  function AbsoluteActivation() {
    this.type = $HKRw$var$ActivationType.AbsoluteActivation;
  }

  AbsoluteActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return Math.abs(x);
    } else {
      return x < 0 ? -1 : 1;
    }
  };

  return AbsoluteActivation;
}();

var $HKRw$export$AbsoluteActivation = $HKRw$var$AbsoluteActivation;
$HKRw$exports.AbsoluteActivation = $HKRw$export$AbsoluteActivation;

var $HKRw$var$InverseActivation =
/** @class */
function () {
  function InverseActivation() {
    this.type = $HKRw$var$ActivationType.InverseActivation;
  }

  InverseActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    if (!derivative) {
      return 1 - x;
    } else {
      return -1;
    }
  };

  return InverseActivation;
}();

var $HKRw$export$InverseActivation = $HKRw$var$InverseActivation;
$HKRw$exports.InverseActivation = $HKRw$export$InverseActivation;

var $HKRw$var$SELUActivation =
/** @class */
function () {
  function SELUActivation() {
    this.type = $HKRw$var$ActivationType.SELUActivation;
  }

  SELUActivation.prototype.calc = function (x, derivative) {
    if (derivative === void 0) {
      derivative = false;
    }

    var alpha = 1.6732632423543772848170429916717;
    var scale = 1.0507009873554804934193349852946;

    if (!derivative) {
      if (x > 0) {
        return x * scale;
      } else {
        return alpha * Math.exp(x) - alpha * scale;
      }
    } else if (x > 0) {
      return scale;
    } else {
      return alpha * Math.exp(x) * scale;
    }
  };

  return SELUActivation;
}();

var $HKRw$export$SELUActivation = $HKRw$var$SELUActivation;
$HKRw$exports.SELUActivation = $HKRw$export$SELUActivation;
var $HKRw$var$ActivationType;

(function (ActivationType) {
  ActivationType[ActivationType["NO_ACTIVATION"] = 0] = "NO_ACTIVATION";
  ActivationType[ActivationType["LogisticActivation"] = 1] = "LogisticActivation";
  ActivationType[ActivationType["TanhActivation"] = 2] = "TanhActivation";
  ActivationType[ActivationType["IdentityActivation"] = 3] = "IdentityActivation";
  ActivationType[ActivationType["StepActivation"] = 4] = "StepActivation";
  ActivationType[ActivationType["RELUActivation"] = 5] = "RELUActivation";
  ActivationType[ActivationType["SoftsignActivation"] = 6] = "SoftsignActivation";
  ActivationType[ActivationType["SinusoidActivation"] = 7] = "SinusoidActivation";
  ActivationType[ActivationType["GaussianActivation"] = 8] = "GaussianActivation";
  ActivationType[ActivationType["BentIdentityActivation"] = 9] = "BentIdentityActivation";
  ActivationType[ActivationType["BipolarActivation"] = 10] = "BipolarActivation";
  ActivationType[ActivationType["BipolarSigmoidActivation"] = 11] = "BipolarSigmoidActivation";
  ActivationType[ActivationType["HardTanhActivation"] = 12] = "HardTanhActivation";
  ActivationType[ActivationType["AbsoluteActivation"] = 13] = "AbsoluteActivation";
  ActivationType[ActivationType["InverseActivation"] = 14] = "InverseActivation";
  ActivationType[ActivationType["SELUActivation"] = 15] = "SELUActivation";
})($HKRw$var$ActivationType = $HKRw$export$ActivationType || ($HKRw$export$ActivationType = {}, $HKRw$exports.ActivationType = $HKRw$export$ActivationType));

var $HKRw$export$ALL_ACTIVATIONS = [$HKRw$var$ActivationType.LogisticActivation, $HKRw$var$ActivationType.TanhActivation, $HKRw$var$ActivationType.IdentityActivation, $HKRw$var$ActivationType.StepActivation, $HKRw$var$ActivationType.RELUActivation, $HKRw$var$ActivationType.SoftsignActivation, $HKRw$var$ActivationType.SinusoidActivation, $HKRw$var$ActivationType.GaussianActivation, $HKRw$var$ActivationType.BentIdentityActivation, $HKRw$var$ActivationType.BipolarActivation, $HKRw$var$ActivationType.BipolarSigmoidActivation, $HKRw$var$ActivationType.HardTanhActivation, $HKRw$var$ActivationType.AbsoluteActivation, $HKRw$var$ActivationType.InverseActivation, $HKRw$var$ActivationType.SELUActivation];
$HKRw$exports.ALL_ACTIVATIONS = $HKRw$export$ALL_ACTIVATIONS;
// ASSET: architecture\Connection.js
var $MoWF$exports = {};
Object.defineProperty($MoWF$exports, "__esModule", {
  value: true
});

var $MoWF$var$Connection =
/** @class */
function () {
  function Connection(from, to, weight, gateNode) {
    this.from = from;
    this.to = to;
    this.weight = weight || 0;
    this.gain = 1;
    this.eligibility = 0;
    this.deltaWeightsPrevious = 0;
    this.deltaWeightsTotal = 0;
    this.xTraceNodes = [];
    this.xTraceValues = [];

    if (gateNode) {
      this.gateNode = gateNode;
      gateNode.addGate(this);
    } else {
      this.gateNode = null;
    }
  }

  Connection.innovationID = function (a, b) {
    return 1 / 2 * (a + b) * (a + b + 1) + b;
  };

  Connection.prototype.toJSON = function () {
    return {
      fromIndex: this.from.index,
      toIndex: this.to.index,
      gateNodeIndex: this.gateNode === null ? null : this.gateNode.index,
      weight: this.weight
    };
  };

  return Connection;
}();

var $MoWF$export$Connection = $MoWF$var$Connection;
$MoWF$exports.Connection = $MoWF$export$Connection;
// ASSET: methods\Utils.js
var $tp3Y$exports = {};
Object.defineProperty($tp3Y$exports, "__esModule", {
  value: true
});

function $tp3Y$var$pickRandom(arr) {
  return arr[$tp3Y$var$randInt(0, arr.length)];
}

var $tp3Y$export$pickRandom = $tp3Y$var$pickRandom;
$tp3Y$exports.pickRandom = $tp3Y$export$pickRandom;

function $tp3Y$var$randInt(min, max) {
  return Math.floor(Math.random() * (max - min) + min);
}

var $tp3Y$export$randInt = $tp3Y$var$randInt;
$tp3Y$exports.randInt = $tp3Y$export$randInt;

function $tp3Y$var$randDouble(min, max) {
  return Math.random() * (max - min) + min;
}

var $tp3Y$export$randDouble = $tp3Y$var$randDouble;
$tp3Y$exports.randDouble = $tp3Y$export$randDouble;

function $tp3Y$var$randBoolean() {
  return Math.random() >= 0.5;
}

var $tp3Y$export$randBoolean = $tp3Y$var$randBoolean;
$tp3Y$exports.randBoolean = $tp3Y$export$randBoolean;

function $tp3Y$var$anyMatch(arr, target) {
  for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
    var elem = arr_1[_i];

    if (elem === target) {
      return true;
    }
  }

  return false;
}

var $tp3Y$export$anyMatch = $tp3Y$var$anyMatch;
$tp3Y$exports.anyMatch = $tp3Y$export$anyMatch;

function $tp3Y$var$remove(arr, elem) {
  var index = arr.indexOf(elem);

  if (index === -1) {
    return false;
  } else {
    arr.splice(index, 1);
    return true;
  }
}

var $tp3Y$export$remove = $tp3Y$var$remove;
$tp3Y$exports.remove = $tp3Y$export$remove;

function $tp3Y$var$getOrDefault(value, defaultValue) {
  return value !== undefined && value !== null ? value : defaultValue;
}

var $tp3Y$export$getOrDefault = $tp3Y$var$getOrDefault;
$tp3Y$exports.getOrDefault = $tp3Y$export$getOrDefault;

function $tp3Y$var$shuffle(array) {
  var counter = array.length; // While there are elements in the array

  while (counter > 0) {
    // Pick a random index
    var index = $tp3Y$var$randInt(0, counter); // Decrease counter by 1

    counter--; // And swap the last element with it

    var temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }

  return array;
}

var $tp3Y$export$shuffle = $tp3Y$var$shuffle;
$tp3Y$exports.shuffle = $tp3Y$export$shuffle;
// ASSET: architecture\Node.js
var $omMI$export$NodeType,
    $omMI$exports = {};
Object.defineProperty($omMI$exports, "__esModule", {
  value: true
});
var $omMI$var$NodeType;

(function (NodeType) {
  NodeType[NodeType["INPUT"] = 0] = "INPUT";
  NodeType[NodeType["HIDDEN"] = 1] = "HIDDEN";
  NodeType[NodeType["OUTPUT"] = 2] = "OUTPUT";
})($omMI$var$NodeType = $omMI$export$NodeType || ($omMI$export$NodeType = {}, $omMI$exports.NodeType = $omMI$export$NodeType));

var $omMI$var$Node =
/** @class */
function () {
  function Node(type) {
    if (type === void 0) {
      type = $omMI$var$NodeType.HIDDEN;
    }

    this.type = type;
    this.bias = $tp3Y$export$randDouble(-1, 1);
    this.squash = new $HKRw$export$LogisticActivation();
    this.activation = 0;
    this.state = 0;
    this.old = 0;
    this.mask = 1;
    this.deltaBiasPrevious = 0;
    this.deltaBiasTotal = 0;
    this.incoming = [];
    this.outgoing = [];
    this.gated = [];
    this.selfConnection = new $MoWF$export$Connection(this, this, 0);
    this.errorResponsibility = 0;
    this.errorProjected = 0;
    this.errorGated = 0;
    this.index = NaN;
  }

  Node.fromJSON = function (json) {
    var node = new Node();
    node.bias = json.bias;
    node.type = json.type;
    node.squash = $HKRw$export$Activation.getActivation(json.squash);
    node.mask = json.mask;
    node.index = json.index;
    return node;
  };

  Node.prototype.clear = function () {
    for (var _i = 0, _a = this.incoming; _i < _a.length; _i++) {
      var connection = _a[_i];
      connection.eligibility = 0;
      connection.xTraceNodes = [];
      connection.xTraceValues = [];
    }

    for (var _b = 0, _c = this.gated; _b < _c.length; _b++) {
      var connection = _c[_b];
      connection.gain = 0;
    }

    this.errorResponsibility = this.errorProjected = this.errorGated = 0;
    this.old = this.state = this.activation = 0;
  };

  Node.prototype.mutateBias = function (method) {
    this.bias += $tp3Y$export$randDouble(method.min, method.max);
  };

  Node.prototype.mutateActivation = function () {
    var newActivationType;

    do {
      newActivationType = $tp3Y$export$pickRandom($HKRw$export$ALL_ACTIVATIONS);
    } while (newActivationType === this.squash.type);

    this.squash = $HKRw$export$Activation.getActivation(newActivationType);
  };

  Node.prototype.isProjectedBy = function (node) {
    if (node === this) {
      return this.selfConnection.weight !== 0;
    } else {
      return $tp3Y$export$anyMatch(this.incoming.map(function (conn) {
        return conn.from;
      }), node);
    }
  };

  Node.prototype.isProjectingTo = function (node) {
    if (node === this) {
      return this.selfConnection.weight !== 0;
    } else {
      return $tp3Y$export$anyMatch(this.outgoing.map(function (conn) {
        return conn.to;
      }), node);
    }
  };

  Node.prototype.addGate = function (connection) {
    this.gated.push(connection);
    connection.gateNode = this;
  };

  Node.prototype.removeGate = function (connection) {
    $tp3Y$export$remove(this.gated, connection);
    connection.gateNode = null;
    connection.gain = 1;
  };

  Node.prototype.connect = function (target, weight, twoSided) {
    if (weight === void 0) {
      weight = 0;
    }

    if (twoSided === void 0) {
      twoSided = false;
    }

    if (target === this) {
      this.selfConnection.weight = weight || 1;
      return this.selfConnection;
    } else if (this.isProjectingTo(target)) {
      throw new ReferenceError();
    } else {
      var connection = new $MoWF$export$Connection(this, target, weight);
      this.outgoing.push(connection);
      target.incoming.push(connection);

      if (twoSided) {
        target.connect(this);
      }

      return connection;
    }
  };

  Node.prototype.disconnect = function (node, twoSided) {
    if (twoSided === void 0) {
      twoSided = false;
    }

    if (node === this) {
      this.selfConnection.weight = 0;
      return this.selfConnection;
    }

    for (var _i = 0, _a = this.outgoing; _i < _a.length; _i++) {
      var connection = _a[_i];

      if (connection.to !== node) {
        continue;
      }

      $tp3Y$export$remove(this.outgoing, connection);
      $tp3Y$export$remove(connection.to.incoming, connection);

      if (connection.gateNode !== undefined && connection.gateNode != null) {
        connection.gateNode.removeGate(connection);
      }

      if (twoSided) {
        node.disconnect(this);
      }

      return connection;
    }

    throw new Error("No connection found!");
  };

  Node.prototype.propagate = function (target, momentum, rate, update) {
    // TODO: check for errors
    if (target !== undefined && Number.isFinite(target)) {
      this.errorResponsibility = this.errorProjected = target - this.activation;
    } else {
      this.errorProjected = 0;

      for (var _i = 0, _a = this.outgoing; _i < _a.length; _i++) {
        var connection = _a[_i];
        this.errorProjected += connection.to.errorResponsibility * connection.weight * connection.gain;
      }

      this.errorProjected *= this.derivative || 1;
      this.errorGated = 0;

      for (var _b = 0, _c = this.gated; _b < _c.length; _b++) {
        var connection = _c[_b];
        var node = connection.to;
        var influence = void 0;

        if (node.selfConnection.gateNode === this) {
          influence = node.old + connection.weight * connection.from.activation;
        } else {
          influence = connection.weight * connection.from.activation;
        }

        this.errorGated += node.errorResponsibility * influence;
      }

      this.errorGated *= this.derivative || 1;
      this.errorResponsibility = this.errorProjected + this.errorGated;
    }

    for (var _d = 0, _e = this.incoming; _d < _e.length; _d++) {
      var connection = _e[_d];
      var gradient = this.errorProjected * connection.eligibility;

      for (var j = 0; j < connection.xTraceNodes.length; j++) {
        var node = connection.xTraceNodes[j];
        gradient += node.errorResponsibility * connection.xTraceValues[j];
      }

      connection.deltaWeightsTotal += rate * gradient * this.mask;

      if (update) {
        connection.deltaWeightsTotal += momentum * connection.deltaWeightsPrevious;
        connection.weight += connection.deltaWeightsTotal;
        connection.deltaWeightsPrevious = connection.deltaWeightsTotal;
        connection.deltaWeightsTotal = 0;
      }
    }

    this.deltaBiasTotal += rate * this.errorResponsibility;

    if (update) {
      this.deltaBiasTotal += momentum * this.deltaBiasPrevious;
      this.bias += this.deltaBiasTotal;
      this.deltaBiasPrevious = this.deltaBiasTotal;
      this.deltaBiasTotal = 0;
    }

    return {
      responsibility: this.errorResponsibility,
      projected: this.errorProjected,
      gated: this.errorGated
    };
  };

  Node.prototype.activate = function (input, trace) {
    var _this = this;

    if (input === void 0) {
      input = null;
    }

    if (trace === void 0) {
      trace = true;
    } // TODO: check for errors


    if (input !== null && Number.isFinite(input)) {
      return this.activation = input;
    }

    if (trace) {
      this.old = this.state;
      this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;
      this.incoming.forEach(function (conn) {
        _this.state += conn.from.activation * conn.weight * conn.gain;
      });
      this.activation = this.squash.calc(this.state, false) * this.mask;
      this.derivative = this.squash.calc(this.state, true);
      var nodes_1 = [];
      var influences_1 = [];
      this.gated.forEach(function (connection) {
        connection.gain = _this.activation;
        var index = nodes_1.indexOf(connection.to);

        if (index > -1) {
          influences_1[index] += connection.weight * connection.from.activation;
        } else {
          nodes_1.push(connection.to);

          if (connection.to.selfConnection.gateNode === _this) {
            influences_1.push(connection.weight * connection.from.activation + connection.to.old);
          } else {
            influences_1.push(connection.weight * connection.from.activation);
          }
        }
      });

      for (var _i = 0, _a = this.incoming; _i < _a.length; _i++) {
        var connection = _a[_i];
        connection.eligibility = this.selfConnection.gain * this.selfConnection.weight * connection.eligibility + connection.from.activation * connection.gain;

        for (var i = 0; i < nodes_1.length; i++) {
          var node = nodes_1[i];
          var influence = influences_1[i];
          var index = connection.xTraceNodes.indexOf(node);
          if (index > -1) connection.xTraceValues[index] = node.selfConnection.gain * node.selfConnection.weight * connection.xTraceValues[index] + this.derivative * connection.eligibility * influence;else {
            connection.xTraceNodes.push(node);
            connection.xTraceValues.push(this.derivative * connection.eligibility * influence);
          }
        }
      }

      return this.activation;
    } else {
      if (this.type === $omMI$var$NodeType.INPUT) return this.activation = 0;
      this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;

      for (var _b = 0, _c = this.incoming; _b < _c.length; _b++) {
        var connection = _c[_b];
        this.state += connection.from.activation * connection.weight * connection.gain;
      }

      this.activation = this.squash.calc(this.state, false);

      for (var _d = 0, _e = this.gated; _d < _e.length; _d++) {
        var connection = _e[_d];
        connection.gain = this.activation;
      }

      return this.activation;
    }
  };

  Node.prototype.toJSON = function () {
    return {
      bias: this.bias,
      type: this.type,
      squash: this.squash.type,
      mask: this.mask,
      index: this.index
    };
  };

  return Node;
}();

var $omMI$export$Node = $omMI$var$Node;
$omMI$exports.Node = $omMI$export$Node;
// ASSET: architecture\layer\DenseLayer.js
var $ygW6$exports = {};

var $ygW6$var$__extends = $ygW6$exports && $ygW6$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($ygW6$exports, "__esModule", {
  value: true
});

var $ygW6$var$DenseLayer =
/** @class */
function (_super) {
  $ygW6$var$__extends(DenseLayer, _super);

  function DenseLayer(inputSize, outputSize) {
    var _this = _super.call(this, inputSize, outputSize) || this;

    for (var i = 0; i < inputSize; i++) {
      _this.nodes.push(new $omMI$export$Node($omMI$export$NodeType.INPUT));
    }

    for (var i = 0; i < outputSize; i++) {
      _this.nodes.push(new $omMI$export$Node($omMI$export$NodeType.INPUT));
    }

    _this.nodes.filter(function (node) {
      return node.type === $omMI$export$NodeType.INPUT;
    }).forEach(function (inputNode) {
      _this.nodes.filter(function (node) {
        return node.type === $omMI$export$NodeType.OUTPUT;
      }).forEach(function (outputNode) {
        _this.connections.push(inputNode.connect(outputNode, 1));
      });
    });

    return _this;
  }

  return DenseLayer;
}($EX0Z$export$Layer);

var $ygW6$export$DenseLayer = $ygW6$var$DenseLayer;
$ygW6$exports.DenseLayer = $ygW6$export$DenseLayer;
// ASSET: architecture\layer\GaussianNoiseLayer.js
var $zIGV$exports = {};

var $zIGV$var$__extends = $zIGV$exports && $zIGV$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($zIGV$exports, "__esModule", {
  value: true
});

var $zIGV$var$GaussianNoiseLayer =
/** @class */
function (_super) {
  $zIGV$var$__extends(GaussianNoiseLayer, _super);

  function GaussianNoiseLayer(inputSize, outputSize) {
    return _super.call(this, inputSize, outputSize) || this;
  }

  return GaussianNoiseLayer;
}($EX0Z$export$Layer);

var $zIGV$export$GaussianNoiseLayer = $zIGV$var$GaussianNoiseLayer;
$zIGV$exports.GaussianNoiseLayer = $zIGV$export$GaussianNoiseLayer;
// ASSET: architecture\layer\InputLayer.js
var $btZp$exports = {};

var $btZp$var$__extends = $btZp$exports && $btZp$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($btZp$exports, "__esModule", {
  value: true
});

var $btZp$var$InputLayer =
/** @class */
function (_super) {
  $btZp$var$__extends(InputLayer, _super);

  function InputLayer(inputSize, outputSize) {
    return _super.call(this, inputSize, outputSize) || this;
  }

  return InputLayer;
}($EX0Z$export$Layer);

var $btZp$export$InputLayer = $btZp$var$InputLayer;
$btZp$exports.InputLayer = $btZp$export$InputLayer;
// ASSET: architecture\layer\LSTMLayer.js
var $NfRv$exports = {};

var $NfRv$var$__extends = $NfRv$exports && $NfRv$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($NfRv$exports, "__esModule", {
  value: true
});

var $NfRv$var$LSTMLayer =
/** @class */
function (_super) {
  $NfRv$var$__extends(LSTMLayer, _super);

  function LSTMLayer(inputSize, outputSize) {
    return _super.call(this, inputSize, outputSize) || this; // TODO: actually implement
  }

  return LSTMLayer;
}($EX0Z$export$Layer);

var $NfRv$export$LSTMLayer = $NfRv$var$LSTMLayer;
$NfRv$exports.LSTMLayer = $NfRv$export$LSTMLayer;
// ASSET: architecture\layer\PoolLayer.js
var $uRrm$export$PoolingType,
    $uRrm$exports = {};

var $uRrm$var$__extends = $uRrm$exports && $uRrm$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($uRrm$exports, "__esModule", {
  value: true
});

var $uRrm$var$PoolLayer =
/** @class */
function (_super) {
  $uRrm$var$__extends(PoolLayer, _super);

  function PoolLayer(inputSize, outputSize, type) {
    return _super.call(this, inputSize, outputSize) || this; // TODO: actually implement it
  }

  return PoolLayer;
}($EX0Z$export$Layer);

var $uRrm$export$PoolLayer = $uRrm$var$PoolLayer;
$uRrm$exports.PoolLayer = $uRrm$export$PoolLayer;
var $uRrm$var$PoolingType;

(function (PoolingType) {
  PoolingType[PoolingType["MaxPooling"] = 0] = "MaxPooling";
  PoolingType[PoolingType["AveragePooling"] = 1] = "AveragePooling";
  PoolingType[PoolingType["GlobalPooling"] = 2] = "GlobalPooling";
})($uRrm$var$PoolingType = $uRrm$export$PoolingType || ($uRrm$export$PoolingType = {}, $uRrm$exports.PoolingType = $uRrm$export$PoolingType));

// ASSET: architecture\layer\RNNLayer.js
var $TCsj$exports = {};

var $TCsj$var$__extends = $TCsj$exports && $TCsj$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($TCsj$exports, "__esModule", {
  value: true
});

var $TCsj$var$RNNLayer =
/** @class */
function (_super) {
  $TCsj$var$__extends(RNNLayer, _super);

  function RNNLayer(inputSize, outputSize) {
    return _super.call(this, inputSize, outputSize) || this;
  }

  return RNNLayer;
}($EX0Z$export$Layer);

var $TCsj$export$RNNLayer = $TCsj$var$RNNLayer;
$TCsj$exports.RNNLayer = $TCsj$export$RNNLayer;
// ASSET: architecture\Architect.js
var $lrqL$exports = {};
Object.defineProperty($lrqL$exports, "__esModule", {
  value: true
});

var $lrqL$var$Architect =
/** @class */
function () {
  function Architect() {
    this.layers = [];
  }

  Architect.prototype.addLayer = function (layer) {
    if (this.layers[this.layers.length - 1].outputSize !== layer.inputSize) {
      throw new RangeError("Output size of last layer is unequal input size of this layer! " + this.layers[this.layers.length - 1].outputSize + " -> " + layer.inputSize);
    }

    this.layers.push(layer);
    return this;
  };

  return Architect;
}();

var $lrqL$export$Architect = $lrqL$var$Architect;
$lrqL$exports.Architect = $lrqL$export$Architect;
// ASSET: methods\Mutation.js
var $LxUz$exports = {};

var $LxUz$var$__extends = $LxUz$exports && $LxUz$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($LxUz$exports, "__esModule", {
  value: true
});

var $LxUz$var$Mutation =
/** @class */
function () {
  function Mutation() {}

  return Mutation;
}();

var $LxUz$export$Mutation = $LxUz$var$Mutation;
$LxUz$exports.Mutation = $LxUz$export$Mutation;

var $LxUz$var$AddNodeMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(AddNodeMutation, _super);

  function AddNodeMutation(randomActivation) {
    if (randomActivation === void 0) {
      randomActivation = true;
    }

    var _this = _super.call(this) || this;

    _this.randomActivation = randomActivation;
    return _this;
  }

  AddNodeMutation.prototype.mutate = function (genome, maxNodes) {
    if (maxNodes !== undefined && genome.nodes.length >= maxNodes) {
      return;
    }

    var node = new $omMI$export$Node($omMI$export$NodeType.HIDDEN);

    if (this.randomActivation) {
      node.mutateActivation();
    }

    var connection = $tp3Y$export$pickRandom(genome.connections);
    var from = connection.from;
    var to = connection.to;
    genome.disconnect(from, to);
    var minBound = Math.max(genome.inputSize, 1 + genome.nodes.indexOf(from));
    genome.nodes.splice(minBound, 0, node);
    var newConnection1 = genome.connect(from, node, 1);
    var newConnection2 = genome.connect(node, to, connection.weight);

    if (connection.gateNode != null) {
      if ($tp3Y$export$randBoolean()) {
        genome.addGate(connection.gateNode, newConnection1);
      } else {
        genome.addGate(connection.gateNode, newConnection2);
      }
    }
  };

  return AddNodeMutation;
}($LxUz$var$Mutation);

var $LxUz$export$AddNodeMutation = $LxUz$var$AddNodeMutation;
$LxUz$exports.AddNodeMutation = $LxUz$export$AddNodeMutation;

var $LxUz$var$SubNodeMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(SubNodeMutation, _super);

  function SubNodeMutation(keepGates) {
    if (keepGates === void 0) {
      keepGates = true;
    }

    var _this = _super.call(this) || this;

    _this.keepGates = keepGates;
    return _this;
  }

  SubNodeMutation.prototype.mutate = function (genome) {
    var possible = genome.nodes.filter(function (node) {
      return node !== undefined && node.type === $omMI$export$NodeType.HIDDEN;
    });

    if (possible.length > 0) {
      var node = $tp3Y$export$pickRandom(possible);
      genome.removeNode(node);
    }
  };

  return SubNodeMutation;
}($LxUz$var$Mutation);

var $LxUz$export$SubNodeMutation = $LxUz$var$SubNodeMutation;
$LxUz$exports.SubNodeMutation = $LxUz$export$SubNodeMutation;

var $LxUz$var$AddConnectionMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(AddConnectionMutation, _super);

  function AddConnectionMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AddConnectionMutation.prototype.mutate = function (genome, maxConnections) {
    if (maxConnections !== undefined && maxConnections <= genome.connections.length) {
      return;
    }

    var possible = [];

    for (var i = 0; i < genome.nodes.length - genome.outputSize; i++) {
      var from = genome.nodes[i];

      for (var j = Math.max(i + 1, genome.inputSize); j < genome.nodes.length; j++) {
        var to = genome.nodes[j];

        if (!from.isProjectingTo(to)) {
          possible.push([from, to]);
        }
      }
    }

    if (possible.length > 0) {
      var pair = $tp3Y$export$pickRandom(possible);
      genome.connect(pair[0], pair[1]);
    }
  };

  return AddConnectionMutation;
}($LxUz$var$Mutation);

var $LxUz$export$AddConnectionMutation = $LxUz$var$AddConnectionMutation;
$LxUz$exports.AddConnectionMutation = $LxUz$export$AddConnectionMutation;

var $LxUz$var$SubConnectionMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(SubConnectionMutation, _super);

  function SubConnectionMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SubConnectionMutation.prototype.mutate = function (genome) {
    var possible = genome.connections.filter(function (conn) {
      return conn.from.outgoing.length > 1 && conn.to.incoming.length > 1 && genome.nodes.indexOf(conn.to) > genome.nodes.indexOf(conn.from);
    });

    if (possible.length > 0) {
      var randomConnection = $tp3Y$export$pickRandom(possible);
      genome.disconnect(randomConnection.from, randomConnection.to);
    }
  };

  return SubConnectionMutation;
}($LxUz$var$Mutation);

var $LxUz$export$SubConnectionMutation = $LxUz$var$SubConnectionMutation;
$LxUz$exports.SubConnectionMutation = $LxUz$export$SubConnectionMutation;

var $LxUz$var$ModWeightMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(ModWeightMutation, _super);

  function ModWeightMutation(min, max) {
    if (min === void 0) {
      min = -1;
    }

    if (max === void 0) {
      max = 1;
    }

    var _this = _super.call(this) || this;

    _this.min = min;
    _this.max = max;
    return _this;
  }

  ModWeightMutation.prototype.mutate = function (genome) {
    $tp3Y$export$pickRandom(genome.connections).weight += $tp3Y$export$randDouble(this.min, this.max);
  };

  return ModWeightMutation;
}($LxUz$var$Mutation);

var $LxUz$export$ModWeightMutation = $LxUz$var$ModWeightMutation;
$LxUz$exports.ModWeightMutation = $LxUz$export$ModWeightMutation;

var $LxUz$var$ModBiasMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(ModBiasMutation, _super);

  function ModBiasMutation(min, max) {
    if (min === void 0) {
      min = -1;
    }

    if (max === void 0) {
      max = 1;
    }

    var _this = _super.call(this) || this;

    _this.min = min;
    _this.max = max;
    return _this;
  }

  ModBiasMutation.prototype.mutate = function (genome) {
    $tp3Y$export$pickRandom(genome.nodes.filter(function (node) {
      return node.type !== $omMI$export$NodeType.INPUT;
    })).mutateBias(this);
  };

  return ModBiasMutation;
}($LxUz$var$Mutation);

var $LxUz$export$ModBiasMutation = $LxUz$var$ModBiasMutation;
$LxUz$exports.ModBiasMutation = $LxUz$export$ModBiasMutation;

var $LxUz$var$ModActivationMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(ModActivationMutation, _super);

  function ModActivationMutation(mutateOutput) {
    if (mutateOutput === void 0) {
      mutateOutput = false;
    }

    var _this = _super.call(this) || this;

    _this.mutateOutput = mutateOutput;
    return _this;
  }

  ModActivationMutation.prototype.mutate = function (genome, max) {
    var possible = this.mutateOutput ? genome.nodes.filter(function (node) {
      return node.type !== $omMI$export$NodeType.INPUT;
    }) : genome.nodes.filter(function (node) {
      return node.type === $omMI$export$NodeType.HIDDEN;
    });

    if (possible.length > 0) {
      $tp3Y$export$pickRandom(possible).mutateActivation();
    }
  };

  return ModActivationMutation;
}($LxUz$var$Mutation);

var $LxUz$export$ModActivationMutation = $LxUz$var$ModActivationMutation;
$LxUz$exports.ModActivationMutation = $LxUz$export$ModActivationMutation;

var $LxUz$var$AddSelfConnectionMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(AddSelfConnectionMutation, _super);

  function AddSelfConnectionMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AddSelfConnectionMutation.prototype.mutate = function (genome) {
    var possible = genome.nodes.filter(function (node) {
      return node.type !== $omMI$export$NodeType.INPUT;
    }).filter(function (node) {
      return node.selfConnection.weight === 0;
    });

    if (possible) {
      var node = $tp3Y$export$pickRandom(possible);
      genome.connect(node, node);
    }
  };

  return AddSelfConnectionMutation;
}($LxUz$var$Mutation);

var $LxUz$export$AddSelfConnectionMutation = $LxUz$var$AddSelfConnectionMutation;
$LxUz$exports.AddSelfConnectionMutation = $LxUz$export$AddSelfConnectionMutation;

var $LxUz$var$SubSelfConnectionMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(SubSelfConnectionMutation, _super);

  function SubSelfConnectionMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SubSelfConnectionMutation.prototype.mutate = function (genome) {
    var possible = genome.connections.filter(function (conn) {
      return conn.from === conn.to;
    });

    if (possible.length > 0) {
      var randomConnection = $tp3Y$export$pickRandom(possible);
      genome.disconnect(randomConnection.from, randomConnection.to);
    }
  };

  return SubSelfConnectionMutation;
}($LxUz$var$Mutation);

var $LxUz$export$SubSelfConnectionMutation = $LxUz$var$SubSelfConnectionMutation;
$LxUz$exports.SubSelfConnectionMutation = $LxUz$export$SubSelfConnectionMutation;

var $LxUz$var$AddGateMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(AddGateMutation, _super);

  function AddGateMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AddGateMutation.prototype.mutate = function (genome, maxGates) {
    if (maxGates !== undefined && maxGates <= genome.gates.length) {
      return;
    }

    var possible = genome.connections.filter(function (conn) {
      return conn.gateNode === null;
    });

    if (possible.length > 0) {
      var node = $tp3Y$export$pickRandom(genome.nodes.filter(function (node) {
        return node.type !== $omMI$export$NodeType.INPUT;
      }));
      var connection = $tp3Y$export$pickRandom(possible);
      genome.addGate(node, connection);
    }
  };

  return AddGateMutation;
}($LxUz$var$Mutation);

var $LxUz$export$AddGateMutation = $LxUz$var$AddGateMutation;
$LxUz$exports.AddGateMutation = $LxUz$export$AddGateMutation;

var $LxUz$var$SubGateMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(SubGateMutation, _super);

  function SubGateMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SubGateMutation.prototype.mutate = function (genome) {
    if (genome.gates.length > 0) {
      genome.removeGate($tp3Y$export$pickRandom(genome.gates));
    }
  };

  return SubGateMutation;
}($LxUz$var$Mutation);

var $LxUz$export$SubGateMutation = $LxUz$var$SubGateMutation;
$LxUz$exports.SubGateMutation = $LxUz$export$SubGateMutation;

var $LxUz$var$AddBackConnectionMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(AddBackConnectionMutation, _super);

  function AddBackConnectionMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AddBackConnectionMutation.prototype.mutate = function (genome) {
    var possible = [];

    for (var i = genome.inputSize; i < genome.nodes.length; i++) {
      var from = genome.nodes[i];

      for (var j = genome.inputSize; j < i; j++) {
        var to = genome.nodes[j];

        if (!from.isProjectingTo(to)) {
          possible.push([from, to]);
        }
      }
    }

    if (possible.length > 0) {
      var pair = $tp3Y$export$pickRandom(possible);
      genome.connect(pair[0], pair[1]);
    }
  };

  return AddBackConnectionMutation;
}($LxUz$var$Mutation);

var $LxUz$export$AddBackConnectionMutation = $LxUz$var$AddBackConnectionMutation;
$LxUz$exports.AddBackConnectionMutation = $LxUz$export$AddBackConnectionMutation;

var $LxUz$var$SubBackConnectionMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(SubBackConnectionMutation, _super);

  function SubBackConnectionMutation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SubBackConnectionMutation.prototype.mutate = function (genome) {
    var possible = genome.connections.filter(function (conn) {
      return conn.from.outgoing.length > 1;
    }).filter(function (conn) {
      return conn.to.incoming.length > 1;
    }).filter(function (conn) {
      return genome.nodes.indexOf(conn.from) > genome.nodes.indexOf(conn.to);
    });

    if (possible.length > 0) {
      var randomConnection = $tp3Y$export$pickRandom(possible);
      genome.disconnect(randomConnection.from, randomConnection.to);
    }
  };

  return SubBackConnectionMutation;
}($LxUz$var$Mutation);

var $LxUz$export$SubBackConnectionMutation = $LxUz$var$SubBackConnectionMutation;
$LxUz$exports.SubBackConnectionMutation = $LxUz$export$SubBackConnectionMutation;

var $LxUz$var$SwapNodesMutation =
/** @class */
function (_super) {
  $LxUz$var$__extends(SwapNodesMutation, _super);

  function SwapNodesMutation(mutateOutput) {
    if (mutateOutput === void 0) {
      mutateOutput = false;
    }

    var _this = _super.call(this) || this;

    _this.mutateOutput = mutateOutput;
    return _this;
  }

  SwapNodesMutation.prototype.mutate = function (genome) {
    var possible = this.mutateOutput ? genome.nodes.filter(function (node) {
      return node !== undefined && node.type !== $omMI$export$NodeType.INPUT;
    }) : genome.nodes.filter(function (node) {
      return node !== undefined && node.type === $omMI$export$NodeType.HIDDEN;
    });

    if (possible.length >= 2) {
      var node1_1 = $tp3Y$export$pickRandom(possible);
      var node2 = $tp3Y$export$pickRandom(possible.filter(function (node) {
        return node !== node1_1;
      }));
      var biasTemp = node1_1.bias;
      var squashTemp = node1_1.squash;
      node1_1.bias = node2.bias;
      node1_1.squash = node2.squash;
      node2.bias = biasTemp;
      node2.squash = squashTemp;
    }
  };

  return SwapNodesMutation;
}($LxUz$var$Mutation);

var $LxUz$export$SwapNodesMutation = $LxUz$var$SwapNodesMutation;
$LxUz$exports.SwapNodesMutation = $LxUz$export$SwapNodesMutation;
var $LxUz$export$ALL_MUTATIONS = [new $LxUz$var$AddNodeMutation(), new $LxUz$var$SubNodeMutation(), new $LxUz$var$AddConnectionMutation(), new $LxUz$var$SubConnectionMutation(), new $LxUz$var$ModWeightMutation(), new $LxUz$var$ModBiasMutation(), new $LxUz$var$ModActivationMutation(), new $LxUz$var$AddGateMutation(), new $LxUz$var$SubGateMutation(), new $LxUz$var$AddSelfConnectionMutation(), new $LxUz$var$SubSelfConnectionMutation(), new $LxUz$var$AddBackConnectionMutation(), new $LxUz$var$SubBackConnectionMutation(), new $LxUz$var$SwapNodesMutation()];
$LxUz$exports.ALL_MUTATIONS = $LxUz$export$ALL_MUTATIONS;
var $LxUz$export$FEEDFORWARD_MUTATIONS = [new $LxUz$var$AddNodeMutation(), new $LxUz$var$SubNodeMutation(), new $LxUz$var$AddConnectionMutation(), new $LxUz$var$SubConnectionMutation(), new $LxUz$var$ModWeightMutation(), new $LxUz$var$ModBiasMutation(), new $LxUz$var$ModActivationMutation(), new $LxUz$var$SwapNodesMutation()];
$LxUz$exports.FEEDFORWARD_MUTATIONS = $LxUz$export$FEEDFORWARD_MUTATIONS;
// ASSET: methods\Loss.js
var $EkJw$exports = {};

var $EkJw$var$__extends = $EkJw$exports && $EkJw$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($EkJw$exports, "__esModule", {
  value: true
});

var $EkJw$var$Loss =
/** @class */
function () {
  function Loss() {}

  return Loss;
}();

var $EkJw$export$Loss = $EkJw$var$Loss;
$EkJw$exports.Loss = $EkJw$export$Loss;

var $EkJw$var$CrossEntropyLoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(CrossEntropyLoss, _super);

  function CrossEntropyLoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  CrossEntropyLoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    outputs.forEach(function (value, index) {
      error -= targets[index] * Math.log(Math.max(value, 1e-15)) + (1 - targets[index]) * Math.log(1 - Math.max(value, 1e-15));
    });
    return error / outputs.length;
  };

  return CrossEntropyLoss;
}($EkJw$var$Loss);

var $EkJw$export$CrossEntropyLoss = $EkJw$var$CrossEntropyLoss;
$EkJw$exports.CrossEntropyLoss = $EkJw$export$CrossEntropyLoss;

var $EkJw$var$MSELoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(MSELoss, _super);

  function MSELoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MSELoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    outputs.forEach(function (value, index) {
      error += Math.pow(targets[index] - value, 2);
    });
    return error / outputs.length;
  };

  return MSELoss;
}($EkJw$var$Loss);

var $EkJw$export$MSELoss = $EkJw$var$MSELoss;
$EkJw$exports.MSELoss = $EkJw$export$MSELoss;

var $EkJw$var$BinaryLoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(BinaryLoss, _super);

  function BinaryLoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  BinaryLoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    outputs.forEach(function (value, index) {
      error += Math.round(targets[index] * 2) !== Math.round(value * 2) ? 1 : 0;
    });
    return error / outputs.length;
  };

  return BinaryLoss;
}($EkJw$var$Loss);

var $EkJw$export$BinaryLoss = $EkJw$var$BinaryLoss;
$EkJw$exports.BinaryLoss = $EkJw$export$BinaryLoss;

var $EkJw$var$MAELoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(MAELoss, _super);

  function MAELoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MAELoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    outputs.forEach(function (value, index) {
      error += Math.abs(targets[index] - value);
    });
    return error / outputs.length;
  };

  return MAELoss;
}($EkJw$var$Loss);

var $EkJw$export$MAELoss = $EkJw$var$MAELoss;
$EkJw$exports.MAELoss = $EkJw$export$MAELoss;

var $EkJw$var$MAPELoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(MAPELoss, _super);

  function MAPELoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MAPELoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    outputs.forEach(function (value, index) {
      error += Math.abs((value - targets[index]) / Math.max(targets[index], 1e-15));
    });
    return error / outputs.length;
  };

  return MAPELoss;
}($EkJw$var$Loss);

var $EkJw$export$MAPELoss = $EkJw$var$MAPELoss;
$EkJw$exports.MAPELoss = $EkJw$export$MAPELoss;

var $EkJw$var$WAPELoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(WAPELoss, _super);

  function WAPELoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  WAPELoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    var sum = 0;

    for (var i = 0; i < outputs.length; i++) {
      error += Math.abs(targets[i] - outputs[i]);
      sum += targets[i];
    }

    return error / sum;
  };

  return WAPELoss;
}($EkJw$var$Loss);

var $EkJw$export$WAPELoss = $EkJw$var$WAPELoss;
$EkJw$exports.WAPELoss = $EkJw$export$WAPELoss;

var $EkJw$var$MSLELoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(MSLELoss, _super);

  function MSLELoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MSLELoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    outputs.forEach(function (value, index) {
      error += Math.log(Math.max(targets[index], 1e-15)) - Math.log(Math.max(value, 1e-15));
    });
    return error / outputs.length;
  };

  return MSLELoss;
}($EkJw$var$Loss);

var $EkJw$export$MSLELoss = $EkJw$var$MSLELoss;
$EkJw$exports.MSLELoss = $EkJw$export$MSLELoss;

var $EkJw$var$HINGELoss =
/** @class */
function (_super) {
  $EkJw$var$__extends(HINGELoss, _super);

  function HINGELoss() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  HINGELoss.prototype.calc = function (targets, outputs) {
    var error = 0;
    outputs.forEach(function (value, index) {
      error += Math.max(0, 1 - value * targets[index]);
    });
    return error / outputs.length;
  };

  return HINGELoss;
}($EkJw$var$Loss);

var $EkJw$export$HINGELoss = $EkJw$var$HINGELoss;
$EkJw$exports.HINGELoss = $EkJw$export$HINGELoss;
// ASSET: methods\Rate.js
var $jsXg$exports = {};

var $jsXg$var$__extends = $jsXg$exports && $jsXg$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($jsXg$exports, "__esModule", {
  value: true
});

var $jsXg$var$Rate = function () {
  function Rate(baseRate) {
    this.baseRate = baseRate;
  }

  return Rate;
}();

var $jsXg$export$Rate = $jsXg$var$Rate;
$jsXg$exports.Rate = $jsXg$export$Rate;

var $jsXg$var$FixedRate =
/** @class */
function (_super) {
  $jsXg$var$__extends(FixedRate, _super);

  function FixedRate() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  FixedRate.prototype.calc = function (iteration) {
    return this.baseRate;
  };

  return FixedRate;
}($jsXg$var$Rate);

var $jsXg$export$FixedRate = $jsXg$var$FixedRate;
$jsXg$exports.FixedRate = $jsXg$export$FixedRate;

var $jsXg$var$StepRate =
/** @class */
function (_super) {
  $jsXg$var$__extends(StepRate, _super);

  function StepRate(baseRate, gamma, stepSize) {
    if (gamma === void 0) {
      gamma = 0.9;
    }

    if (stepSize === void 0) {
      stepSize = 100;
    }

    var _this = _super.call(this, baseRate) || this;

    _this.gamma = gamma;
    _this.stepSize = stepSize;
    return _this;
  }

  StepRate.prototype.calc = function (iteration) {
    return this.baseRate * Math.pow(this.gamma, Math.floor(iteration / this.stepSize));
  };

  return StepRate;
}($jsXg$var$Rate);

var $jsXg$export$StepRate = $jsXg$var$StepRate;
$jsXg$exports.StepRate = $jsXg$export$StepRate;

var $jsXg$var$ExponentialRate =
/** @class */
function (_super) {
  $jsXg$var$__extends(ExponentialRate, _super);

  function ExponentialRate(baseRate, gamma) {
    if (gamma === void 0) {
      gamma = 0.999;
    }

    var _this = _super.call(this, baseRate) || this;

    _this.gamma = gamma;
    return _this;
  }

  ExponentialRate.prototype.calc = function (iteration) {
    return this.baseRate * Math.pow(this.gamma, iteration);
  };

  return ExponentialRate;
}($jsXg$var$Rate);

var $jsXg$export$ExponentialRate = $jsXg$var$ExponentialRate;
$jsXg$exports.ExponentialRate = $jsXg$export$ExponentialRate;

var $jsXg$var$InverseRate =
/** @class */
function (_super) {
  $jsXg$var$__extends(InverseRate, _super);

  function InverseRate(baseRate, gamma, power) {
    if (gamma === void 0) {
      gamma = 0.001;
    }

    if (power === void 0) {
      power = 2;
    }

    var _this = _super.call(this, baseRate) || this;

    _this.gamma = gamma;
    _this.power = power;
    return _this;
  }

  InverseRate.prototype.calc = function (iteration) {
    return this.baseRate * Math.pow(1 + this.gamma * iteration, -this.power);
  };

  return InverseRate;
}($jsXg$var$Rate);

var $jsXg$export$InverseRate = $jsXg$var$InverseRate;
$jsXg$exports.InverseRate = $jsXg$export$InverseRate;
// ASSET: methods\Selection.js
var $Axil$exports = {};

var $Axil$var$__extends = $Axil$exports && $Axil$exports.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty($Axil$exports, "__esModule", {
  value: true
});

var $Axil$var$Selection = function () {
  function Selection() {}

  return Selection;
}();

var $Axil$export$Selection = $Axil$var$Selection;
$Axil$exports.Selection = $Axil$export$Selection;

var $Axil$var$FitnessProportionateSelection =
/** @class */
function (_super) {
  $Axil$var$__extends(FitnessProportionateSelection, _super);

  function FitnessProportionateSelection() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  FitnessProportionateSelection.prototype.select = function (population) {
    var _a;

    var totalFitness = 0;
    var minimalFitness = 0;
    population.map(function (genome) {
      return genome.score;
    }).forEach(function (score) {
      minimalFitness = score !== undefined && score < minimalFitness ? score : minimalFitness;
      totalFitness += score !== null && score !== void 0 ? score : 0;
    });
    minimalFitness = Math.abs(minimalFitness);
    totalFitness += minimalFitness * population.length;
    var random = $tp3Y$export$randDouble(0, totalFitness);
    var value = 0;

    for (var _i = 0, population_1 = population; _i < population_1.length; _i++) {
      var genome = population_1[_i];
      value += ((_a = genome.score) !== null && _a !== void 0 ? _a : 0) + minimalFitness;

      if (random < value) {
        return genome;
      }
    }

    return $tp3Y$export$pickRandom(population);
  };

  return FitnessProportionateSelection;
}($Axil$var$Selection);

var $Axil$export$FitnessProportionateSelection = $Axil$var$FitnessProportionateSelection;
$Axil$exports.FitnessProportionateSelection = $Axil$export$FitnessProportionateSelection;

var $Axil$var$PowerSelection =
/** @class */
function (_super) {
  $Axil$var$__extends(PowerSelection, _super);

  function PowerSelection(power) {
    if (power === void 0) {
      power = 4;
    }

    var _this = _super.call(this) || this;

    _this.power = power;
    return _this;
  }

  PowerSelection.prototype.select = function (population) {
    return population[Math.floor(Math.pow(Math.random(), this.power) * population.length)];
  };

  return PowerSelection;
}($Axil$var$Selection);

var $Axil$export$PowerSelection = $Axil$var$PowerSelection;
$Axil$exports.PowerSelection = $Axil$export$PowerSelection;

var $Axil$var$TournamentSelection =
/** @class */
function (_super) {
  $Axil$var$__extends(TournamentSelection, _super);

  function TournamentSelection(size, probability) {
    if (size === void 0) {
      size = 5;
    }

    if (probability === void 0) {
      probability = 0.5;
    }

    var _this = _super.call(this) || this;

    _this.size = size;
    _this.probability = probability;
    return _this;
  }

  TournamentSelection.prototype.select = function (population) {
    if (this.size > population.length) {
      throw new Error("Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size");
    } // Create a tournament


    var individuals = [];

    for (var i = 0; i < this.size; i++) {
      individuals.push($tp3Y$export$pickRandom(population));
    } // Sort the tournament individuals by score


    individuals.sort(function (a, b) {
      return b.score === undefined || a.score === undefined ? 0 : b.score - a.score;
    }); // Select an individual

    for (var i = 0; i < this.size; i++) {
      if (Math.random() < this.probability || i === this.size - 1) {
        return individuals[i];
      }
    }

    return $tp3Y$export$pickRandom(population);
  };

  return TournamentSelection;
}($Axil$var$Selection);

var $Axil$export$TournamentSelection = $Axil$var$TournamentSelection;
$Axil$exports.TournamentSelection = $Axil$export$TournamentSelection;
// ASSET: NEAT.js
var $y2mK$exports = {};

var $y2mK$var$__awaiter = $y2mK$exports && $y2mK$exports.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var $y2mK$var$__generator = $y2mK$exports && $y2mK$exports.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var $y2mK$var$__spreadArrays = $y2mK$exports && $y2mK$exports.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }

  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }

  return r;
};

Object.defineProperty($y2mK$exports, "__esModule", {
  value: true
});

var $y2mK$var$NEAT =
/** @class */
function () {
  function NEAT(dataset, options) {
    this.dataset = dataset;
    this.generation = $tp3Y$export$getOrDefault(options.generation, 0);
    this.input = $tp3Y$export$getOrDefault(options.input, 1);
    this.output = $tp3Y$export$getOrDefault(options.output, 1);
    this.equal = $tp3Y$export$getOrDefault(options.equal, true);
    this.clear = $tp3Y$export$getOrDefault(options.clear, false);
    this.populationSize = $tp3Y$export$getOrDefault(options.populationSize, 50);
    this.growth = $tp3Y$export$getOrDefault(options.growth, 0.0001);
    this.loss = $tp3Y$export$getOrDefault(options.loss, new $EkJw$export$MSELoss());
    this.amount = $tp3Y$export$getOrDefault(options.amount, 1);
    this.elitism = $tp3Y$export$getOrDefault(options.elitism, 1);
    this.provenance = $tp3Y$export$getOrDefault(options.provenance, 0);
    this.mutationRate = $tp3Y$export$getOrDefault(options.mutationRate, 0.4);
    this.mutationAmount = $tp3Y$export$getOrDefault(options.mutationAmount, 1);
    this.fitnessPopulation = $tp3Y$export$getOrDefault(options.fitnessPopulation, false);
    this.fitnessFunction = options.fitnessFunction;
    this.selection = $tp3Y$export$getOrDefault(options.selection, new $Axil$export$PowerSelection());
    this.mutations = $tp3Y$export$getOrDefault(options.mutations, $LxUz$export$FEEDFORWARD_MUTATIONS);
    this.template = $tp3Y$export$getOrDefault(options.template, new $lOtm$export$Network(this.input, this.output));
    this.maxNodes = $tp3Y$export$getOrDefault(options.maxNodes, Infinity);
    this.maxConnections = $tp3Y$export$getOrDefault(options.maxConnections, Infinity);
    this.maxGates = $tp3Y$export$getOrDefault(options.maxGates, Infinity);
    this.population = [];
    this.createInitialPopulation();
  }

  NEAT.prototype.filterGenome = function (population, template, pickGenome, adjustGenome) {
    var filtered = $y2mK$var$__spreadArrays(population); // avoid mutations

    if (adjustGenome) {
      filtered.filter(function (genome) {
        return pickGenome(genome);
      }).forEach(function (genome, index) {
        return filtered[index] = adjustGenome(filtered[index]);
      });
    } else {
      filtered.filter(function (genome) {
        return pickGenome(genome);
      }).forEach(function (genome, index) {
        return filtered[index] = template.copy();
      });
    }

    return filtered;
  };

  NEAT.prototype.mutateRandom = function (genome, possible) {
    if (possible === void 0) {
      possible = this.mutations;
    }

    var maxNodes = this.maxNodes;
    var maxConnections = this.maxConnections;
    var maxGates = this.maxGates;
    possible = possible.filter(function (method) {
      return method.constructor.name !== $LxUz$export$AddNodeMutation.constructor.name || genome.nodes.length < maxNodes || method.constructor.name !== $LxUz$export$AddConnectionMutation.constructor.name || genome.connections.length < maxConnections || method.constructor.name !== $LxUz$export$AddGateMutation.constructor.name || genome.gates.length < maxGates;
    });
    genome.mutate($tp3Y$export$pickRandom(possible));
  };

  NEAT.prototype.evolve = function (pickGenome, adjustGenome) {
    return $y2mK$var$__awaiter(this, void 0, void 0, function () {
      var elitists, i, newPopulation, i, fittest;

      var _a;

      return $y2mK$var$__generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            // Check if evolve is possible
            if (this.elitism + this.provenance > this.populationSize) {
              throw new Error("Can`t evolve! Elitism + provenance exceeds population size!");
            }

            if (!(this.population[this.population.length - 1].score === undefined)) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.evaluate(this.dataset)];

          case 1:
            _b.sent();

            _b.label = 2;

          case 2:
            if (pickGenome) {
              this.population = this.filterGenome(this.population, this.template, pickGenome, adjustGenome);
            } // Sort in order of fitness (fittest first)


            this.sort();
            elitists = [];

            for (i = 0; i < this.elitism; i++) {
              elitists.push(this.population[i]);
            }

            newPopulation = Array(this.provenance).fill(this.template.copy()); // Breed the next individuals

            for (i = 0; i < this.populationSize - this.elitism - this.provenance; i++) {
              newPopulation.push(this.getOffspring());
            } // Replace the old population with the new population


            this.population = newPopulation; // Mutate the new population

            this.mutate(undefined); // Add the elitists

            (_a = this.population).push.apply(_a, elitists); // evaluate the population


            return [4
            /*yield*/
            , this.evaluate(this.dataset)];

          case 3:
            // evaluate the population
            _b.sent(); // Check & adjust genomes as needed


            if (pickGenome) {
              this.population = this.filterGenome(this.population, this.template, pickGenome, adjustGenome);
            } // Sort in order of fitness (fittest first)


            this.sort();
            fittest = this.population[0].copy();
            fittest.score = this.population[0].score; // Reset the scores

            this.population.forEach(function (genome) {
              return genome.score = undefined;
            });
            this.generation++;
            return [2
            /*return*/
            , fittest];
        }
      });
    });
  };

  NEAT.prototype.getOffspring = function () {
    this.sort();
    var parent1 = this.selection.select(this.population);
    var parent2 = this.selection.select(this.population);

    if (parent1 === null || parent2 === null) {
      throw new ReferenceError("Should not be null!");
    }

    return $lOtm$export$Network.crossOver(parent1, parent2, this.equal);
  };

  NEAT.prototype.mutate = function (method) {
    var _this = this;

    if (method) {
      // Elitist genomes should not be included
      this.population.filter(function () {
        return Math.random() <= _this.mutationRate;
      }).forEach(function (genome) {
        for (var i = 0; i < _this.mutationAmount; i++) {
          genome.mutate(method);
        }
      });
    } else {
      // Elitist genomes should not be included
      this.population.filter(function () {
        return Math.random() <= _this.mutationRate;
      }).forEach(function (genome) {
        for (var i = 0; i < _this.mutationAmount; i++) {
          _this.mutateRandom(genome, _this.mutations);
        }
      });
    }
  };

  NEAT.prototype.evaluate = function (dataset) {
    return $y2mK$var$__awaiter(this, void 0, void 0, function () {
      var _i, _a, genome;

      return $y2mK$var$__generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            if (!this.fitnessPopulation) return [3
            /*break*/
            , 3];

            if (this.clear) {
              this.population.forEach(function (genome) {
                return genome.clear();
              });
            }

            if (!this.fitnessFunction) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.fitnessFunction(dataset, this.population)];

          case 1:
            _b.sent();

            _b.label = 2;

          case 2:
            return [3
            /*break*/
            , 7];

          case 3:
            _i = 0, _a = this.population;
            _b.label = 4;

          case 4:
            if (!(_i < _a.length)) return [3
            /*break*/
            , 7];
            genome = _a[_i];

            if (this.clear) {
              genome.clear();
            }

            if (!this.fitnessFunction) return [3
            /*break*/
            , 6];
            return [4
            /*yield*/
            , this.fitnessFunction(dataset, genome)];

          case 5:
            _b.sent();

            _b.label = 6;

          case 6:
            _i++;
            return [3
            /*break*/
            , 4];

          case 7:
            // Sort the population in order of fitness
            this.sort();
            return [2
            /*return*/
            , this.population[0]];
        }
      });
    });
  };

  NEAT.prototype.sort = function () {
    this.population.sort(function (a, b) {
      return a.score === undefined || b.score === undefined ? 0 : b.score - a.score;
    });
  };

  NEAT.prototype.getFittest = function () {
    return $y2mK$var$__awaiter(this, void 0, void 0, function () {
      return $y2mK$var$__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!(this.population[this.population.length - 1].score === undefined)) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.evaluate(this.dataset)];

          case 1:
            _a.sent();

            _a.label = 2;

          case 2:
            this.sort();
            return [2
            /*return*/
            , this.population[0]];
        }
      });
    });
  };

  NEAT.prototype.getAverage = function () {
    return $y2mK$var$__awaiter(this, void 0, void 0, function () {
      var score;
      return $y2mK$var$__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!(this.population[this.population.length - 1].score === undefined)) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this.evaluate(this.dataset)];

          case 1:
            _a.sent();

            _a.label = 2;

          case 2:
            score = 0;
            this.population.map(function (genome) {
              return genome.score;
            }).forEach(function (val) {
              return score += val !== null && val !== void 0 ? val : 0;
            });
            return [2
            /*return*/
            , score / this.population.length];
        }
      });
    });
  };

  NEAT.prototype.createInitialPopulation = function () {
    for (var i = 0; i < this.populationSize; i++) {
      this.population.push(this.template.copy());
    }
  };

  return NEAT;
}();

var $y2mK$export$NEAT = $y2mK$var$NEAT;
$y2mK$exports.NEAT = $y2mK$export$NEAT;
// ASSET: architecture\Network.js
var $lOtm$exports = {};

var $lOtm$var$__awaiter = $lOtm$exports && $lOtm$exports.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var $lOtm$var$__generator = $lOtm$exports && $lOtm$exports.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty($lOtm$exports, "__esModule", {
  value: true
});

var $lOtm$var$Network =
/** @class */
function () {
  function Network(inputSize, outputSize) {
    this.inputSize = inputSize;
    this.outputSize = outputSize;
    this.nodes = [];
    this.connections = [];
    this.gates = [];
    this.score = undefined;

    for (var i = 0; i < inputSize; i++) {
      this.nodes.push(new $omMI$export$Node($omMI$export$NodeType.INPUT));
    }

    for (var i = 0; i < outputSize; i++) {
      this.nodes.push(new $omMI$export$Node($omMI$export$NodeType.OUTPUT));
    }

    for (var i = 0; i < this.inputSize; i++) {
      for (var j = this.inputSize; j < this.outputSize + this.inputSize; j++) {
        var weight = (Math.random() - 0.5) * this.inputSize * Math.sqrt(2 / this.inputSize);
        this.connect(this.nodes[i], this.nodes[j], weight);
      }
    }
  }

  Network.fromJSON = function (json) {
    var network = new Network(json.inputSize, json.outputSize);
    network.nodes = [];
    network.connections = [];
    json.nodes.forEach(function (nodeJSON) {
      var node = $omMI$export$Node.fromJSON(nodeJSON);
      network.nodes[node.index] = node;
    });
    json.connections.forEach(function (jsonConnection) {
      var connection = network.connect(network.nodes[jsonConnection.fromIndex], network.nodes[jsonConnection.toIndex], jsonConnection.weight);

      if (jsonConnection.gateNodeIndex != null) {
        network.addGate(network.nodes[jsonConnection.gateNodeIndex], connection);
      }
    });
    return network;
  };

  Network.crossOver = function (network1, network2, equal) {
    if (network1.inputSize !== network2.inputSize || network1.outputSize !== network2.outputSize) {
      throw new Error("Networks don`t have the same input/output size!");
    } // Initialise offspring


    var offspring = new Network(network1.inputSize, network1.outputSize);
    offspring.connections = [];
    offspring.nodes = []; // Save scores and create a copy

    var score1 = network1.score || 0;
    var score2 = network2.score || 0; // Determine offspring node size

    var offspringSize;

    if (equal || score1 === score2) {
      var max = Math.max(network1.nodes.length, network2.nodes.length);
      var min = Math.min(network1.nodes.length, network2.nodes.length);
      offspringSize = $tp3Y$export$randInt(min, max + 1);
    } else if (score1 > score2) {
      offspringSize = network1.nodes.length;
    } else {
      offspringSize = network2.nodes.length;
    }

    var inputSize = network1.inputSize;
    var outputSize = network1.outputSize;

    for (var i = 0; i < network1.nodes.length; i++) {
      network1.nodes[i].index = i;
    }

    for (var i = 0; i < network2.nodes.length; i++) {
      network2.nodes[i].index = i;
    } // Assign nodes from parents to offspring


    for (var i = 0; i < offspringSize; i++) {
      var chosenNode = void 0;
      var chosenNodeType = null;

      if (i < inputSize) {
        chosenNodeType = $omMI$export$NodeType.INPUT;
        var sourceNetwork = $tp3Y$export$randBoolean() ? network1 : network2;
        var inputNumber = -1;
        var j = -1;

        while (inputNumber < i) {
          j++;

          if (j >= sourceNetwork.nodes.length) {
            // something is wrong...
            throw RangeError('something is wrong with the size of the input');
          }

          if (sourceNetwork.nodes[j].type === $omMI$export$NodeType.INPUT) {
            inputNumber++;
          }
        }

        chosenNode = sourceNetwork.nodes[j];
      } else if (i < inputSize + outputSize) {
        // now select output nodes
        chosenNodeType = $omMI$export$NodeType.OUTPUT;
        var sourceNetwork = $tp3Y$export$randBoolean() ? network1 : network2;
        var outputNumber = -1;
        var j = -1;

        while (outputNumber < i - inputSize) {
          j++;

          if (j >= sourceNetwork.nodes.length) {
            throw RangeError('something is wrong with the size of the output');
          }

          if (sourceNetwork.nodes[j].type === $omMI$export$NodeType.OUTPUT) {
            outputNumber++;
          }
        }

        chosenNode = sourceNetwork.nodes[j];
      } else {
        chosenNodeType = $omMI$export$NodeType.HIDDEN;
        var sourceNetwork = void 0;

        if (i >= network1.nodes.length) {
          sourceNetwork = network2;
        } else if (i >= network2.nodes.length) {
          sourceNetwork = network1;
        } else {
          sourceNetwork = $tp3Y$export$randBoolean() ? network1 : network2;
        }

        chosenNode = $tp3Y$export$pickRandom(sourceNetwork.nodes);
      }

      var newNode = new $omMI$export$Node(chosenNode.type);
      newNode.bias = chosenNode.bias;
      newNode.squash = chosenNode.squash;
      offspring.nodes.push(newNode);
    } // Create arrays of connection genes


    var n1connections = [];
    var n2connections = []; // Add the connections of network 1

    network1.connections.forEach(function (connection) {
      n1connections[$MoWF$export$Connection.innovationID(connection.from.index, connection.to.index)] = connection.toJSON();
    }); // Add the connections of network 2

    network2.connections.forEach(function (connection) {
      n2connections[$MoWF$export$Connection.innovationID(connection.from.index, connection.to.index)] = connection.toJSON();
    }); // Split common conn genes from disjoint or excess conn genes

    var connections = [];
    var keys1 = Object.keys(n1connections);
    var keys2 = Object.keys(n2connections);

    for (var i = keys1.length - 1; i >= 0; i--) {
      if (n2connections[parseInt(keys1[i])] !== undefined) {
        connections.push($tp3Y$export$randBoolean() ? n1connections[parseInt(keys1[i])] : n2connections[parseInt(keys1[i])]);
        n2connections[parseInt(keys1[i])] = undefined;
      } else if (score1 >= score2 || equal) {
        connections.push(n1connections[parseInt(keys1[i])]);
      }
    } // Excess/disjoint gene


    if (score2 >= score1 || equal) {
      keys2.map(function (key) {
        return parseInt(key);
      }).map(function (key) {
        return n2connections[key];
      }).filter(function (conn) {
        return conn !== undefined;
      }).forEach(function (conn) {
        return connections.push(conn);
      });
    } // Add common conn genes uniformly


    connections.forEach(function (connectionJSON) {
      if (connectionJSON !== undefined && connectionJSON.toIndex < offspringSize && connectionJSON.fromIndex < offspringSize) {
        var from = offspring.nodes[connectionJSON.fromIndex];
        var to = offspring.nodes[connectionJSON.toIndex];
        var connection = offspring.connect(from, to, connectionJSON.weight);

        if (connectionJSON.gateNodeIndex !== null && connectionJSON.gateNodeIndex < offspringSize) {
          offspring.addGate(offspring.nodes[connectionJSON.gateNodeIndex], connection);
        }
      }
    });
    return offspring;
  };

  Network.prototype.copy = function () {
    return Network.fromJSON(this.toJSON());
  };

  Network.prototype.connect = function (from, to, weight) {
    if (weight === void 0) {
      weight = 0;
    }

    var connection = from.connect(to, weight);
    this.connections.push(connection);
    return connection;
  };

  Network.prototype.activate = function (input, dropoutRate, trace) {
    if (dropoutRate === void 0) {
      dropoutRate = 0;
    }

    if (trace === void 0) {
      trace = true;
    }

    var inputNodeIndex = 0;

    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
      var node = _a[_i];

      if (inputNodeIndex === this.inputSize) {
        break;
      }

      if (node.type !== $omMI$export$NodeType.INPUT) {
        continue;
      }

      node.activate(input[inputNodeIndex++], trace);
    }

    if (inputNodeIndex !== input.length) {
      throw Error("There are " + inputNodeIndex + " input nodes, but " + input.length + " inputs were passed");
    }

    this.nodes.filter(function (node) {
      return node.type === $omMI$export$NodeType.HIDDEN;
    }).forEach(function (node) {
      if (dropoutRate) {
        node.mask = Math.random() >= dropoutRate ? 1 : 0;
      }

      node.activate(undefined, trace);
    });
    var output = [];

    for (var _b = 0, _c = this.nodes; _b < _c.length; _b++) {
      var node = _c[_b];

      if (output.length === this.outputSize) {
        break;
      }

      if (node.type !== $omMI$export$NodeType.OUTPUT) {
        continue;
      }

      output.push(node.activate(undefined, trace));
    }

    if (output.length !== this.outputSize) {
      throw Error("There are " + this.outputSize + " output nodes, but " + output.length + " outputs were passed");
    }

    return output;
  };

  Network.prototype.propagate = function (rate, momentum, update, target) {
    if (target.length !== this.outputSize) {
      throw new Error("Output target length should match network output length");
    }

    var targetIndex = 0;

    for (var i = 0; targetIndex < this.outputSize; i++) {
      if (this.nodes[i].type === $omMI$export$NodeType.OUTPUT) {
        this.nodes[i].propagate(target[targetIndex++], momentum, rate, update);
      }
    }

    for (var i = this.nodes.length - 1; i >= 0; i--) {
      if (this.nodes[i].type === $omMI$export$NodeType.HIDDEN) {
        this.nodes[i].propagate(undefined, rate, momentum, update);
      }
    }

    this.nodes.filter(function (node) {
      return node.type === $omMI$export$NodeType.INPUT;
    }).forEach(function (node) {
      node.propagate(undefined, rate, momentum, update);
    });
  };

  Network.prototype.clear = function () {
    this.nodes.forEach(function (node) {
      return node.clear();
    });
  };

  Network.prototype.disconnect = function (from, to) {
    var _this = this;

    this.connections.filter(function (conn) {
      return conn.from === from;
    }).filter(function (conn) {
      return conn.to === to;
    }).forEach(function (conn) {
      if (conn.gateNode !== null) {
        _this.removeGate(conn);
      }

      $tp3Y$export$remove(_this.connections, conn);
    });
    return from.disconnect(to);
  };

  Network.prototype.addGate = function (node, connection) {
    if (this.nodes.indexOf(node) === -1) {
      throw new ReferenceError("This node is not part of the network!");
    } else if (connection.gateNode != null) {
      return;
    }

    node.addGate(connection);
    this.gates.push(connection);
  };

  Network.prototype.removeGate = function (connection) {
    if (!$tp3Y$export$anyMatch(this.gates, connection)) {
      throw new Error("This connection is not gated!");
    }

    $tp3Y$export$remove(this.gates, connection);

    if (connection.gateNode != null) {
      connection.gateNode.removeGate(connection);
    }
  };

  Network.prototype.removeNode = function (node, keepGates) {
    var _this = this;

    if (keepGates === void 0) {
      keepGates = new $LxUz$export$SubNodeMutation().keepGates;
    }

    if (!$tp3Y$export$anyMatch(this.nodes, node)) {
      throw new ReferenceError("This node does not exist in the network!");
    }

    this.disconnect(node, node);
    var inputs = [];
    var gates = [];
    var outputs = [];

    for (var i = node.incoming.length - 1; i >= 0; i--) {
      var connection = node.incoming[i];

      if (keepGates && connection.gateNode !== null && connection.gateNode !== node) {
        gates.push(connection.gateNode);
      }

      inputs.push(connection.from);
      this.disconnect(connection.from, node);
    }

    for (var i = node.outgoing.length - 1; i >= 0; i--) {
      var connection = node.outgoing[i];

      if (keepGates && connection.gateNode !== null && connection.gateNode !== node) {
        gates.push(connection.gateNode);
      }

      outputs.push(connection.to);
      this.disconnect(node, connection.to);
    }

    var connections = [];
    inputs.forEach(function (input) {
      outputs.forEach(function (output) {
        if (!input.isProjectingTo(output)) {
          connections.push(_this.connect(input, output));
        }
      });
    });

    while (gates.length > 0 && connections.length > 0) {
      var gate = gates.shift();

      if (gate === undefined) {
        continue;
      }

      var connection = $tp3Y$export$pickRandom(connections);
      this.addGate(gate, connection);
      $tp3Y$export$remove(connections, connection);
    }

    for (var i = node.gated.length - 1; i >= 0; i--) {
      this.removeGate(node.gated[i]);
    }

    $tp3Y$export$remove(this.nodes, node);
  };

  Network.prototype.mutate = function (method, maxNodes, maxConnections, maxGates) {
    if (maxNodes === void 0) {
      maxNodes = Infinity;
    }

    if (maxConnections === void 0) {
      maxConnections = Infinity;
    }

    if (maxGates === void 0) {
      maxGates = Infinity;
    }

    var _a;

    method.mutate(this, (_a = maxNodes !== null && maxNodes !== void 0 ? maxNodes : maxConnections) !== null && _a !== void 0 ? _a : maxGates);
  };

  Network.prototype.mutateRandom = function (allowedMethods, maxNodes, maxConnections, maxGates) {
    if (allowedMethods === void 0) {
      allowedMethods = $LxUz$export$ALL_MUTATIONS;
    }

    if (maxNodes === void 0) {
      maxNodes = Infinity;
    }

    if (maxConnections === void 0) {
      maxConnections = Infinity;
    }

    if (maxGates === void 0) {
      maxGates = Infinity;
    }

    if (allowedMethods.length === 0) {
      return;
    }

    this.mutate($tp3Y$export$pickRandom(allowedMethods), maxNodes || Infinity, maxConnections || Infinity, maxGates || Infinity);
  };

  Network.prototype.train = function (dataset, options) {
    if (options === void 0) {
      options = {};
    }

    var _a;

    if (dataset[0].input.length !== this.inputSize || dataset[0].output.length !== this.outputSize) {
      throw new Error("Dataset input/output size should be same as network input/output size!");
    }

    options.iterations = $tp3Y$export$getOrDefault(options.iterations, 100);
    options.error = $tp3Y$export$getOrDefault(options.error, 0.05);
    options.loss = $tp3Y$export$getOrDefault(options.loss, new $EkJw$export$MSELoss());
    var baseRate = $tp3Y$export$getOrDefault(options.rate, 0.3);
    options.dropout = $tp3Y$export$getOrDefault(options.dropout, 0);
    options.momentum = $tp3Y$export$getOrDefault(options.momentum, 0);
    options.batchSize = Math.min(dataset.length, $tp3Y$export$getOrDefault(options.batchSize, 1));
    options.ratePolicy = $tp3Y$export$getOrDefault(options.ratePolicy, new $jsXg$export$FixedRate(baseRate));
    options.log = $tp3Y$export$getOrDefault(options.log, NaN);
    var targetError = options.error <= 0 ? -1 : options.error;
    var start = Date.now(); // check for errors

    if (options.iterations <= 0 && options.error <= 0) {
      throw new Error("At least one of the following options must be specified: error, iterations");
    }

    var trainingSetSize;
    var trainingSet;
    var testSet;

    if (options.crossValidateTestSize && options.crossValidateTestSize > 0) {
      trainingSetSize = Math.ceil((1 - options.crossValidateTestSize) * dataset.length);
      trainingSet = dataset.slice(0, trainingSetSize);
      testSet = dataset.slice(trainingSetSize);
    } else {
      trainingSet = dataset;
      testSet = [];
    }

    var currentTrainingRate;
    var iterationCount = 0;
    var error = 1;

    while (error > targetError && (options.iterations <= 0 || iterationCount < options.iterations)) {
      iterationCount++;
      currentTrainingRate = options.ratePolicy.calc(iterationCount);
      var trainError = this.trainEpoch(trainingSet, options.batchSize, currentTrainingRate, options.momentum, options.loss, options.dropout);

      if (options.clear) {
        this.clear();
      } // Checks if cross validation is enabled


      if (options.crossValidateTestSize) {
        error = this.test(testSet, options.loss);

        if (options.clear) {
          this.clear();
        }
      } else {
        error = trainError;
      }

      if ((_a = options.shuffle) !== null && _a !== void 0 ? _a : false) {
        $tp3Y$export$shuffle(dataset);
      }

      if (options.log > 0 && iterationCount % options.log === 0) {
        console.log("iteration number", iterationCount, "error", error, "training rate", currentTrainingRate);
      }

      if (options.schedule && iterationCount % options.schedule.iterations === 0) {
        options.schedule.function(error, iterationCount);
      }
    }

    if (options.clear) {
      this.clear();
    }

    return {
      error: error,
      iterations: iterationCount,
      time: Date.now() - start
    };
  };

  Network.prototype.trainEpoch = function (dataset, batchSize, trainingRate, momentum, loss, dropoutRate) {
    if (dropoutRate === void 0) {
      dropoutRate = 0.5;
    }

    var errorSum = 0;

    for (var i = 0; i < dataset.length; i++) {
      var input = dataset[i].input;
      var correctOutput = dataset[i].output;
      var update = (i + 1) % batchSize === 0 || i + 1 === dataset.length;
      var output = this.activate(input, dropoutRate);
      this.propagate(trainingRate, momentum, update, correctOutput);
      errorSum += loss.calc(correctOutput, output);
    }

    return errorSum / dataset.length;
  };

  Network.prototype.test = function (dataset, loss) {
    if (loss === void 0) {
      loss = new $EkJw$export$MSELoss();
    }

    var error = 0;

    for (var _i = 0, dataset_1 = dataset; _i < dataset_1.length; _i++) {
      var entry = dataset_1[_i];
      var input = entry.input;
      var target = entry.output;
      var output = this.activate(input, undefined, false);
      error += loss.calc(target, output);
    }

    return error / dataset.length;
  };

  Network.prototype.toJSON = function () {
    var json = {
      nodes: [],
      connections: [],
      inputSize: this.inputSize,
      outputSize: this.outputSize
    };

    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].index = i;
    }

    this.nodes.forEach(function (node) {
      json.nodes.push(node.toJSON());

      if (node.selfConnection.weight !== 0) {
        json.connections.push(node.selfConnection.toJSON());
      }
    });
    this.connections.forEach(function (conn) {
      return json.connections.push(conn.toJSON());
    });
    return json;
  };

  Network.prototype.evolve = function (dataset, options) {
    var _a, _b, _c;

    return $lOtm$var$__awaiter(this, void 0, void 0, function () {
      var targetError, start, neat, error, bestFitness, bestGenome, fittest, fitness;
      return $lOtm$var$__generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            if (dataset[0].input.length !== this.inputSize || dataset[0].output.length !== this.outputSize) {
              throw new Error("Dataset input/output size should be same as network input/output size!");
            }

            targetError = 0;

            if (typeof options.iterations === "undefined" && typeof options.error === "undefined") {
              options.iterations = 1000;
              targetError = 0.05;
            } else if (options.iterations) {
              targetError = -1;
            } else if (options.error) {
              targetError = options.error;
              options.iterations = 0;
            }

            options.growth = $tp3Y$export$getOrDefault(options.growth, 0.0001);
            options.loss = $tp3Y$export$getOrDefault(options.loss, new $EkJw$export$MSELoss());
            options.amount = $tp3Y$export$getOrDefault(options.amount, 1);
            options.fitnessPopulation = $tp3Y$export$getOrDefault(options.fitnessPopulation, false);
            options.maxNodes = $tp3Y$export$getOrDefault(options.maxNodes, Infinity);
            options.maxConnections = $tp3Y$export$getOrDefault(options.maxConnections, Infinity);
            options.maxGates = $tp3Y$export$getOrDefault(options.maxGates, Infinity);
            start = Date.now();

            options.fitnessFunction = function (dataset, population) {
              return $lOtm$var$__awaiter(this, void 0, void 0, function () {
                var _this = this;

                return $lOtm$var$__generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      if (!Array.isArray(population)) {
                        population = [population];
                      }

                      return [4
                      /*yield*/
                      , Promise.all(population.map(function (genome) {
                        return $lOtm$var$__awaiter(_this, void 0, void 0, function () {
                          var score, i;

                          var _a, _b, _c;

                          return $lOtm$var$__generator(this, function (_d) {
                            score = 0;

                            for (i = 0; i < ((_a = options.amount) !== null && _a !== void 0 ? _a : 1); i++) {
                              score -= genome.test(dataset, options.loss);
                            }

                            score -= (_b = options.growth) !== null && _b !== void 0 ? _b : 0.0001 * (genome.nodes.length - genome.inputSize - genome.outputSize + genome.connections.length + genome.gates.length);
                            genome.score = score / ((_c = options.amount) !== null && _c !== void 0 ? _c : 1);
                            return [2
                            /*return*/
                            ];
                          });
                        });
                      }))];

                    case 1:
                      _a.sent();

                      return [2
                      /*return*/
                      ];
                  }
                });
              });
            };

            options.fitnessPopulation = true;
            options.template = this;
            options.input = this.inputSize;
            options.output = this.outputSize;
            neat = new $y2mK$export$NEAT(dataset, options);
            error = -Infinity;
            bestFitness = -Infinity;
            _d.label = 1;

          case 1:
            if (!(error < -targetError && (options.iterations === 0 || neat.generation < ((_a = options.iterations) !== null && _a !== void 0 ? _a : 0)))) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , neat.evolve(undefined, undefined)];

          case 2:
            fittest = _d.sent();
            fitness = fittest.score === undefined ? -Infinity : fittest.score;
            error = fitness + options.growth * (fittest.nodes.length - fittest.inputSize - fittest.outputSize + fittest.connections.length + fittest.gates.length);

            if (fitness > bestFitness) {
              bestFitness = fitness;
              bestGenome = fittest;
            }

            if (((_b = options.log) !== null && _b !== void 0 ? _b : 0) > 0 && neat.generation % ((_c = options.log) !== null && _c !== void 0 ? _c : 0) === 0) {
              console.log("iteration", neat.generation, "fitness", fitness, "error", -error);
            }

            if (options.schedule && neat.generation % options.schedule.iterations === 0) {
              options.schedule.function(fitness, -error, neat.generation);
            }

            return [3
            /*break*/
            , 1];

          case 3:
            if (bestGenome !== undefined) {
              this.nodes = bestGenome.nodes;
              this.connections = bestGenome.connections;
              this.gates = bestGenome.gates;

              if (options.clear) {
                this.clear();
              }
            }

            return [2
            /*return*/
            , {
              error: -error,
              iterations: neat.generation,
              time: Date.now() - start
            }];
        }
      });
    });
  };

  return Network;
}();

var $lOtm$export$Network = $lOtm$var$Network;
$lOtm$exports.Network = $lOtm$export$Network;
// ASSET: architecture\node.js
var $fRQ6$export$NodeType,
    $fRQ6$exports = {};
Object.defineProperty($fRQ6$exports, "__esModule", {
  value: true
});
var $fRQ6$var$NodeType;

(function (NodeType) {
  NodeType[NodeType["INPUT"] = 0] = "INPUT";
  NodeType[NodeType["HIDDEN"] = 1] = "HIDDEN";
  NodeType[NodeType["OUTPUT"] = 2] = "OUTPUT";
})($fRQ6$var$NodeType = $fRQ6$export$NodeType || ($fRQ6$export$NodeType = {}, $fRQ6$exports.NodeType = $fRQ6$export$NodeType));

var $fRQ6$var$Node = function () {
  function Node(type) {
    if (type === void 0) {
      type = $fRQ6$var$NodeType.HIDDEN;
    }

    this.type = type;
    this.bias = $tp3Y$export$randDouble(-1, 1);
    this.squash = new $HKRw$export$LogisticActivation();
    this.activation = 0;
    this.state = 0;
    this.old = 0;
    this.mask = 1;
    this.deltaBiasPrevious = 0;
    this.deltaBiasTotal = 0;
    this.incoming = [];
    this.outgoing = [];
    this.gated = [];
    this.selfConnection = new $MoWF$export$Connection(this, this, 0);
    this.errorResponsibility = 0;
    this.errorProjected = 0;
    this.errorGated = 0;
    this.index = NaN;
  }

  Node.fromJSON = function (json) {
    var node = new Node();
    node.bias = json.bias;
    node.type = json.type;
    node.squash = $HKRw$export$Activation.getActivation(json.squash);
    node.mask = json.mask;
    node.index = json.index;
    return node;
  };

  Node.prototype.clear = function () {
    for (var _i = 0, _a = this.incoming; _i < _a.length; _i++) {
      var connection = _a[_i];
      connection.eligibility = 0;
      connection.xTraceNodes = [];
      connection.xTraceValues = [];
    }

    for (var _b = 0, _c = this.gated; _b < _c.length; _b++) {
      var connection = _c[_b];
      connection.gain = 0;
    }

    this.errorResponsibility = this.errorProjected = this.errorGated = 0;
    this.old = this.state = this.activation = 0;
  };

  Node.prototype.mutateBias = function (method) {
    this.bias += $tp3Y$export$randDouble(method.min, method.max);
  };

  Node.prototype.mutateActivation = function () {
    var newActivationType;

    do {
      newActivationType = $tp3Y$export$pickRandom($HKRw$export$ALL_ACTIVATIONS);
    } while (newActivationType === this.squash.type);

    this.squash = $HKRw$export$Activation.getActivation(newActivationType);
  };

  Node.prototype.isProjectedBy = function (node) {
    if (node === this) {
      return this.selfConnection.weight !== 0;
    } else {
      return $tp3Y$export$anyMatch(this.incoming.map(function (conn) {
        return conn.from;
      }), node);
    }
  };

  Node.prototype.isProjectingTo = function (node) {
    if (node === this) {
      return this.selfConnection.weight !== 0;
    } else {
      return $tp3Y$export$anyMatch(this.outgoing.map(function (conn) {
        return conn.to;
      }), node);
    }
  };

  Node.prototype.addGate = function (connection) {
    this.gated.push(connection);
    connection.gateNode = this;
  };

  Node.prototype.removeGate = function (connection) {
    $tp3Y$export$remove(this.gated, connection);
    connection.gateNode = null;
    connection.gain = 1;
  };

  Node.prototype.connect = function (target, weight, twoSided) {
    if (weight === void 0) {
      weight = 0;
    }

    if (twoSided === void 0) {
      twoSided = false;
    }

    if (target === this) {
      this.selfConnection.weight = weight || 1;
      return this.selfConnection;
    } else if (this.isProjectingTo(target)) {
      throw new ReferenceError();
    } else {
      var connection = new $MoWF$export$Connection(this, target, weight);
      this.outgoing.push(connection);
      target.incoming.push(connection);

      if (twoSided) {
        target.connect(this);
      }

      return connection;
    }
  };

  Node.prototype.disconnect = function (node, twoSided) {
    if (twoSided === void 0) {
      twoSided = false;
    }

    if (node === this) {
      this.selfConnection.weight = 0;
      return this.selfConnection;
    }

    for (var _i = 0, _a = this.outgoing; _i < _a.length; _i++) {
      var connection = _a[_i];

      if (connection.to !== node) {
        continue;
      }

      $tp3Y$export$remove(this.outgoing, connection);
      $tp3Y$export$remove(connection.to.incoming, connection);

      if (connection.gateNode !== undefined && connection.gateNode != null) {
        connection.gateNode.removeGate(connection);
      }

      if (twoSided) {
        node.disconnect(this);
      }

      return connection;
    }

    throw new Error("No connection found!");
  };

  Node.prototype.propagate = function (target, momentum, rate, update) {
    if (target !== undefined && Number.isFinite(target)) {
      this.errorResponsibility = this.errorProjected = target - this.activation;
    } else {
      this.errorProjected = 0;

      for (var _i = 0, _a = this.outgoing; _i < _a.length; _i++) {
        var connection = _a[_i];
        this.errorProjected += connection.to.errorResponsibility * connection.weight * connection.gain;
      }

      this.errorProjected *= this.derivative || 1;
      this.errorGated = 0;

      for (var _b = 0, _c = this.gated; _b < _c.length; _b++) {
        var connection = _c[_b];
        var node = connection.to;
        var influence = void 0;

        if (node.selfConnection.gateNode === this) {
          influence = node.old + connection.weight * connection.from.activation;
        } else {
          influence = connection.weight * connection.from.activation;
        }

        this.errorGated += node.errorResponsibility * influence;
      }

      this.errorGated *= this.derivative || 1;
      this.errorResponsibility = this.errorProjected + this.errorGated;
    }

    for (var _d = 0, _e = this.incoming; _d < _e.length; _d++) {
      var connection = _e[_d];
      var gradient = this.errorProjected * connection.eligibility;

      for (var j = 0; j < connection.xTraceNodes.length; j++) {
        var node = connection.xTraceNodes[j];
        gradient += node.errorResponsibility * connection.xTraceValues[j];
      }

      connection.deltaWeightsTotal += rate * gradient * this.mask;

      if (update) {
        connection.deltaWeightsTotal += momentum * connection.deltaWeightsPrevious;
        connection.weight += connection.deltaWeightsTotal;
        connection.deltaWeightsPrevious = connection.deltaWeightsTotal;
        connection.deltaWeightsTotal = 0;
      }
    }

    this.deltaBiasTotal += rate * this.errorResponsibility;

    if (update) {
      this.deltaBiasTotal += momentum * this.deltaBiasPrevious;
      this.bias += this.deltaBiasTotal;
      this.deltaBiasPrevious = this.deltaBiasTotal;
      this.deltaBiasTotal = 0;
    }

    return {
      responsibility: this.errorResponsibility,
      projected: this.errorProjected,
      gated: this.errorGated
    };
  };

  Node.prototype.activate = function (input, trace) {
    var _this = this;

    if (input === void 0) {
      input = null;
    }

    if (trace === void 0) {
      trace = true;
    }

    if (input !== null && Number.isFinite(input)) {
      return this.activation = input;
    }

    if (trace) {
      this.old = this.state;
      this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;
      this.incoming.forEach(function (conn) {
        _this.state += conn.from.activation * conn.weight * conn.gain;
      });
      this.activation = this.squash.calc(this.state, false) * this.mask;
      this.derivative = this.squash.calc(this.state, true);
      var nodes_1 = [];
      var influences_1 = [];
      this.gated.forEach(function (connection) {
        connection.gain = _this.activation;
        var index = nodes_1.indexOf(connection.to);

        if (index > -1) {
          influences_1[index] += connection.weight * connection.from.activation;
        } else {
          nodes_1.push(connection.to);

          if (connection.to.selfConnection.gateNode === _this) {
            influences_1.push(connection.weight * connection.from.activation + connection.to.old);
          } else {
            influences_1.push(connection.weight * connection.from.activation);
          }
        }
      });

      for (var _i = 0, _a = this.incoming; _i < _a.length; _i++) {
        var connection = _a[_i];
        connection.eligibility = this.selfConnection.gain * this.selfConnection.weight * connection.eligibility + connection.from.activation * connection.gain;

        for (var i = 0; i < nodes_1.length; i++) {
          var node = nodes_1[i];
          var influence = influences_1[i];
          var index = connection.xTraceNodes.indexOf(node);
          if (index > -1) connection.xTraceValues[index] = node.selfConnection.gain * node.selfConnection.weight * connection.xTraceValues[index] + this.derivative * connection.eligibility * influence;else {
            connection.xTraceNodes.push(node);
            connection.xTraceValues.push(this.derivative * connection.eligibility * influence);
          }
        }
      }

      return this.activation;
    } else {
      if (this.type === $fRQ6$var$NodeType.INPUT) return this.activation = 0;
      this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;

      for (var _b = 0, _c = this.incoming; _b < _c.length; _b++) {
        var connection = _c[_b];
        this.state += connection.from.activation * connection.weight * connection.gain;
      }

      this.activation = this.squash.calc(this.state, false);

      for (var _d = 0, _e = this.gated; _d < _e.length; _d++) {
        var connection = _e[_d];
        connection.gain = this.activation;
      }

      return this.activation;
    }
  };

  Node.prototype.toJSON = function () {
    return {
      bias: this.bias,
      type: this.type,
      squash: this.squash.type,
      mask: this.mask,
      index: this.index
    };
  };

  return Node;
}();

var $fRQ6$export$Node = $fRQ6$var$Node;
$fRQ6$exports.Node = $fRQ6$export$Node;
// ASSET: index.js
var $Focm$exports = {};
Object.defineProperty($Focm$exports, "__esModule", {
  value: true
});
var $Focm$export$Layer = $EX0Z$export$Layer;
$Focm$exports.Layer = $Focm$export$Layer;
var $Focm$export$ConvolutionLayer = $StXe$export$ConvolutionLayer;
$Focm$exports.ConvolutionLayer = $Focm$export$ConvolutionLayer;
var $Focm$export$DenseLayer = $ygW6$export$DenseLayer;
$Focm$exports.DenseLayer = $Focm$export$DenseLayer;
var $Focm$export$GaussianNoiseLayer = $zIGV$export$GaussianNoiseLayer;
$Focm$exports.GaussianNoiseLayer = $Focm$export$GaussianNoiseLayer;
var $Focm$export$InputLayer = $btZp$export$InputLayer;
$Focm$exports.InputLayer = $Focm$export$InputLayer;
var $Focm$export$LSTMLayer = $NfRv$export$LSTMLayer;
$Focm$exports.LSTMLayer = $Focm$export$LSTMLayer;
var $Focm$export$PoolLayer = $uRrm$export$PoolLayer;
$Focm$exports.PoolLayer = $Focm$export$PoolLayer;
var $Focm$export$RNNLayer = $TCsj$export$RNNLayer;
$Focm$exports.RNNLayer = $Focm$export$RNNLayer;
var $Focm$export$Architect = $lrqL$export$Architect;
$Focm$exports.Architect = $Focm$export$Architect;
var $Focm$export$Connection = $MoWF$export$Connection;
$Focm$exports.Connection = $Focm$export$Connection;
var $Focm$export$Network = $lOtm$export$Network;
$Focm$exports.Network = $Focm$export$Network;
var $Focm$export$Node = $fRQ6$export$Node;
$Focm$exports.Node = $Focm$export$Node;
var $Focm$export$Activation = $HKRw$export$Activation;
$Focm$exports.Activation = $Focm$export$Activation;
var $Focm$export$Loss = $EkJw$export$Loss;
$Focm$exports.Loss = $Focm$export$Loss;
var $Focm$export$Mutation = $LxUz$export$Mutation;
$Focm$exports.Mutation = $Focm$export$Mutation;
var $Focm$export$Rate = $jsXg$export$Rate;
$Focm$exports.Rate = $Focm$export$Rate;
var $Focm$export$Selection = $Axil$export$Selection;
$Focm$exports.Selection = $Focm$export$Selection;
var $Focm$export$NEAT = $y2mK$export$NEAT;
$Focm$exports.NEAT = $Focm$export$NEAT;

if (typeof exports === "object" && typeof module !== "undefined") {
  // CommonJS
  module.exports = $Focm$exports;
} else if (typeof define === "function" && define.amd) {
  // RequireJS
  define(function () {
    return $Focm$exports;
  });
} else {
  // <script>
  this["carrot"] = $Focm$exports;
}
})();